-- version control marker $Id: cgtest19.occ,v 1.9 1997/01/22 10:29:54 dcw Exp $
#OPTION "W"   --   this line goes to krtest.occ
-- #INCLUDE "config.inc"
PROC cgtest19 (CHAN OF BYTE keyb, scr, err)
  --{{{  config.inc
  VAL HOST.CPU.SPARC IS 0:
  VAL HOST.CPU.ALPHA IS 1:
  VAL HOST.CPU.I386 IS 2:
  VAL INT HOST.CPU.TRANSPUTER     IS 200:
  VAL INT HOST.CPU.TRANSTERPRETER IS HOST.CPU.TRANSPUTER:
  VAL HOST.CPU IS HOST.CPU.I386:
  --}}}
  -- #INCLUDE "cgmain.occ"
  -- #INCLUDE "cgreal.occ"
  --{{{  cgmain.occ
  -- version control marker $Id: cgmain.occ,v 3.9 1997/03/06 16:36:15 dcw Exp $
  --{{{  cglib.occ
  -- version control marker $Id: cglib.occ,v 1.6 1997/01/30 12:31:09 dcw Exp $
  --
  -- Cut-down version of the output utilities from the course library
  --{{{  some constants
  VAL BYTE BELL IS 7(BYTE):
  VAL BYTE NULL IS 0(BYTE):
  VAL BYTE BACK IS 8(BYTE):
  VAL BYTE DELETE IS 127(BYTE):
  --}}}
  --{{{  out stuff
  PROC out.repeat (VAL BYTE ch,  VAL INT n,  CHAN OF BYTE out)
    --{{{
    IF
      n > 0
        SEQ i = 0 FOR n
          SEQ
            out ! ch
      TRUE
        SKIP
    --}}}
  :
  PROC out.ch (VAL BYTE ch,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    SEQ
      out.repeat (' ', field - 1, out)
      out ! ch
    --}}}
  :
  PROC out.ch.funny (VAL BYTE ch,  VAL INT field,  CHAN OF [1]BYTE out)
    --{{{
    SEQ
      VAL [1]BYTE thing RETYPES ch:
      out ! thing
    --}}}
  :
  PROC out.nl (CHAN OF BYTE out)
    SEQ
      out ! '*c'
      out ! '*n'
  :
  PROC in.ch (BYTE ch, CHAN OF BYTE in)
    --{{{
    in ? ch
    --}}}
  :
  PROC out.bell (CHAN OF BYTE out)
    --{{{
    out.ch (BELL, 1, out)
    --}}}
  :
  PROC out.string (VAL []BYTE s,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    VAL length IS SIZE s:
    SEQ
      out.repeat (' ', field - length, out)
      SEQ i = 0 FOR length
        SEQ
          out ! s [i]
    --}}}
  :
  PROC out.number (VAL INT n,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    VAL max.digits IS 20:
    [max.digits]INT D:
    INT x, i:
    IF
      (n = 0)
        --{{{  zero
        SEQ
          IF
            (1 < field)
              out.repeat (' ', field - 1, out)
            (TRUE)
              SKIP
          out ! '0'
        --}}}
      (TRUE)
        SEQ
          i := 0     --  bring this line up here,   Vedat
          --{{{  check negative
          IF
            (n < 0)
              SEQ        -- this one can handle MOSTNEG INT as well
                D [i] := -(n\10)
                x := -(n/10)
                i:= i + 1
            (TRUE)         -- (n > 0)
              x := n
          --}}}
          --{{{  decompose
          -- i := 0   -- this line goes up in order to handle MOSTNEG INT
          WHILE x > 0
            SEQ
              D [i] := x\10
              x := x/10
              i := i + 1
          --}}}
          --{{{  pad
          IF
            (n > 0)
              out.repeat (' ', field - i, out)
            (TRUE)
              SEQ
                out.repeat (' ', (field - 1) - i, out)
                out ! '-'
          --}}}
          --{{{  output
          WHILE i > 0
            SEQ
              i := i - 1
              out ! BYTE (D [i] + (INT '0'))
          --}}}
    --}}}
  :
  PROC out.bool (VAL BOOL b,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    IF
      (b = TRUE)
        out.ch ('1', field, out)
      (b = FALSE)
        out.ch ('0', field, out)
      (TRUE)
        out.ch ('.', field, out)
    --}}}
  :
  PROC out.yes.no (VAL BOOL b,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    IF
      b
        out.string ("yes", field, out)
      TRUE
        out.string ("no", field, out)
    --}}}
  :
  PROC out.hex.int (VAL INT x, l, CHAN OF BYTE out)
    --{{{  body of cg.write.hex.int
    -- this procedure ignores the field length parameter 'l'
    -- independent of endianism - DCW
    VAL INT nibble          IS #F:
    VAL INT hex.dig.per.int IS 8:
    VAL INT bit.per.hex.dig IS 4:
    VAL hex.dig             IS "0123456789ABCDEF":
    INT digit, mask, shift:
    [12]BYTE s:
    SEQ
      s[0]:= '#'
      SEQ i = 1 FOR hex.dig.per.int
        SEQ
          shift :=  (hex.dig.per.int - i) * bit.per.hex.dig
          digit := (x >> shift) /\ nibble
          s[i]:= hex.dig[digit]
      out.string ([s FROM 0 FOR (hex.dig.per.int + 1)], 0, out)
    --}}}
  :
  PROC black.hole (CHAN OF BYTE in)
    --{{{
    WHILE TRUE
      BYTE any:
      in ? any
    --}}}
  :
  --}}}
  --}}}
  VAL display.names  IS TRUE :
  --VAL display.names  IS TRUE :
  --VAL display.titles IS display.names :
  VAL display.titles IS TRUE :
  VAL no.of.columns   IS 6 :
  VAL width.of.column IS 10 :
  TIMER timer:                    -- DCW
  INT start.time, end.time:       -- DCW
  INT column.count :
  --{{{  [INLINE] PROC out (VAL INT ch)
  PROC out (VAL INT ch)
    SEQ
      IF
        (ch >= 0) AND (ch < 256)
          scr ! BYTE ch
        TRUE
          SKIP
  :
  --}}}
  --{{{  PROC newline ()
  PROC newline ()
    SEQ
      out.nl (scr)
      column.count := 0
  :
  --}}}
  --{{{  PROC writes (VAL []BYTE s)
  PROC writes (VAL []BYTE s)
    out.string (s, 0, scr)
  :
  --}}}
  --{{{  [INLINE] PROC in (INT ch)
  PROC in (INT ch)
    --all input goes via this proc, but its only ever used to wait
    SEQ
      --newline ()
      --writes ("(Press any key) ")
      -- keyboard ? ch
      ch := ch  -- stop any warning not used
      newline ()
  :
  --}}}
  --{{{  [INLINE] PROC writen (VAL INT n)
  PROC writen (VAL INT n)
    out.number (n, 0, scr)
  :
  --}}}
  --{{{  [INLINE] PROC writehex (VAL INT value, length)
  PROC writehex (VAL INT value, length)
    --VAL hex IS "0123456789ABCDEF" :
    --SEQ
    --  SEQ i = 1 FOR length
    --    out (INT hex [(value >> ((length - i) * 4)) /\ #F] )
    --  out (-2)
    out.hex.int (value, length, scr)
  :
  --}}}
  --{{{  [INLINE] PROC beep ()
  PROC beep ()
    out (7)
  :
  --}}}
  --{{{  PROC failed.test  (VAL []BYTE where)
  PROC failed.test(VAL []BYTE where)
    SEQ
      beep()
      writes(where)
      IF
        display.names
          newline()
        TRUE
          SKIP
      writes (" Failed: ")
  :
  --}}}
  --{{{  PROC completed.ok (VAL []BYTE where)
  INT error.count, passed.count:
  PROC completed.ok (VAL []BYTE where)
    SEQ
      passed.count := passed.count + 1
      IF
        display.names
          SEQ
            writes (where)
            IF
              column.count < no.of.columns
                VAL spaces IS "            " :
                VAL INT n.spaces IS width.of.column - (SIZE where):
                SEQ
                  IF
                    n.spaces > 0
                      writes([spaces FROM 0 FOR width.of.column - (SIZE where)])
                      --SEQ i = 0 FOR width.of.column - (SIZE where)
                      --  out ('*s' (INT))
                    TRUE
                      out ('*s' (INT))
                  column.count := column.count + 1
              TRUE
                newline ()
        TRUE
          SKIP
  :
  --}}}
  INT any.integer.name :
  VAL []BYTE useless.name RETYPES any.integer.name :
  VAL nibbles.per.INT IS (SIZE useless.name) * 2 :
  --{{{  PROC check.BOOL (VAL BOOL val1, val2, VAL []BYTE test.type)
  PROC check.BOOL (VAL BOOL val1, val2, VAL []BYTE test.type)
    INT key :
    PROC writebool (VAL BOOL b)
      IF
        b
          writes ("TRUE")
        TRUE
          writes ("FALSE")
    :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writebool (val1)
            writes ("  ")
            writebool (val2)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check.BYTE (VAL BYTE val1, val2, VAL []BYTE test.type)
  PROC check.BYTE (VAL BYTE val1, val2, VAL []BYTE test.type)
    INT key :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writehex (INT val1, 2)
            writes ("  ")
            writehex (INT val2, 2)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check.INT (VAL INT val1, val2, VAL []BYTE test.type)
  PROC check.INT (VAL INT val1, val2, VAL []BYTE test.type)
    INT key :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writehex (val1, nibbles.per.INT)
            writes ("  ")
            writehex (val2, nibbles.per.INT)
            writes ("  ")
            writen (val1)
            writes ("  ")
            writen (val2)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check (VAL INT val1, val2, VAL []BYTE test.type)
  --INLINE PROC check (VAL INT val1, val2, VAL []BYTE test.type)
  -- If this is inline, every invocation creates an abbreviation
  -- VAL test.type IS "..." :
  -- and this makes the map file huge!
  PROC check (VAL INT val1, val2, VAL []BYTE test.type)
    check.INT (val1, val2, test.type)
    --{{{  COMMENT
    --IF
      --val1 = val2
        --check.INT (val1, val2, test.type)
      --TRUE
        --out.string ("!!! FAILED in check !!!*n*c", 0, out)
    --}}}
  :
  --}}}
  --{{{  PROC init (VAL []BYTE name, description)
  [20]BYTE saved.name :
  INT saved.name.len :
  PROC init (VAL []BYTE name, description)
    SEQ
      timer ? start.time          -- DCW
      writes (name)
      writes ("  --  ")
      writes (description)
      newline ()
      error.count := 0
      passed.count := 0
      saved.name.len := SIZE name
      [saved.name FROM 0 FOR saved.name.len] := name
  :
  --}}}
  --{{{  PROC title (VAL []BYTE string)
  PROC title (VAL []BYTE string)
    IF
      display.titles
        SEQ
          IF
            display.names
              newline ()
            TRUE
              SKIP
            TRUE
              STOP
          writes(string)
          newline()
      TRUE
        SKIP
      TRUE
        STOP
  :
  --}}}
  --{{{  PROC finish ()
  PROC finish ()
    SEQ
      IF
        display.names
          newline ()
        TRUE
          SKIP
      IF
        error.count > 0
          SEQ
            writes ("^^^ Failed : ")
            writes ([saved.name FROM 0 FOR saved.name.len])
            writes (": ")
            writen (error.count)
            writes (" errors detected, ")
        TRUE
          SEQ
            writes ("^^^ Passed : ")
            writes ([saved.name FROM 0 FOR saved.name.len])
            writes (": All ")
      writen (passed.count)
      writes (" tests passed OK")
      timer ? end.time            -- DCW
      newline ()
      writes ("Time = ")
      writen (end.time - start.time)
      writes (" ticks")
      newline ()
  :
  --}}}
  --{{{  identity functions
  -- These are designed to help stop the optimiser constant propagating.
  -- If it manages to defeat these, make them more complex, as long as they
  -- still return the identity function.
  BOOL   FUNCTION id.BOOL   (VAL BOOL   x)
    BOOL res :
    VALOF
      res := x
      RESULT res
  :
  BYTE   FUNCTION id.BYTE   (VAL BYTE   x)
    BYTE   res :
    VALOF
      res := x
      RESULT res
  :
  INT    FUNCTION id.INT    (VAL INT    x)
    INT    res :
    VALOF
      res := x
      RESULT res
  :
  INT16  FUNCTION id.INT16  (VAL INT16  x)
    INT16  res :
    VALOF
      res := x
      RESULT res
  :
  INT32  FUNCTION id.INT32  (VAL INT32  x)
    INT32  res :
    VALOF
      res := x
      RESULT res
  :
  INT64  FUNCTION id.INT64  (VAL INT64  x)
    INT64  res :
    VALOF
      res := x
      RESULT res
  :
  REAL32 FUNCTION id.REAL32 (VAL REAL32 x)
    REAL32 res :
    VALOF
      res := x
      RESULT res
  :
  REAL64 FUNCTION id.REAL64 (VAL REAL64 x)
    REAL64 res :
    VALOF
      res := x
      RESULT res
  :
  INT    FUNCTION id        (VAL INT    x)
    INT    res :
    VALOF
      res := x
      RESULT res
  :
  --}}}
  --}}}
  --{{{  cgreal.occ
  -- version control marker $Id: cgreal.occ,v 1.1 1995/10/10 13:03:56 djb1 Exp $
  --{{{  PROC check.INT16 (VAL INT16 val1, val2, VAL []BYTE test.type)
  PROC check.INT16 (VAL INT16 val1, val2, VAL []BYTE test.type)
    INT key :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writehex (INT val1, 4)
            writes ("  ")
            writehex (INT val2, 4)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC print.failed.values(VAL []BYTE test.type, VAL []INT x1, x2)
  PROC print.failed.values(VAL []BYTE test.type, VAL []INT x1, x2)
    PROC print.value(VAL []INT x)
      SEQ i = 0 FOR SIZE x
        writehex (x [((SIZE x) - 1) - i], nibbles.per.INT)
    :
    INT key :
    SEQ
      failed.test(test.type)
      print.value(x1)
      writes("  ")
      print.value(x2)
      in (key)
      error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check.INT32 (VAL INT32 val1, val2, VAL []BYTE test.type)
  PROC check.INT32 (VAL INT32 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  PROC check.INT64 (VAL INT64 val1, val2, VAL []BYTE test.type)
  PROC check.INT64 (VAL INT64 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  old out.REAL32 and out.REAL64
  --PROC outREAL32 (VAL REAL32 Real)
  --  SKIP
  --:
  --PROC outREAL64 (VAL REAL64 real)
  --  SKIP
  --:
  --}}}
  --{{{  PROC check.REAL32 (VAL REAL32 val1, val2, VAL []BYTE test.type)
  PROC check.REAL32 (VAL REAL32 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  PROC check.REAL64 (VAL REAL64 val1, val2, VAL []BYTE test.type)
  PROC check.REAL64 (VAL REAL64 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  PROC check.string (VAL []BYTE val1, val2, VAL []BYTE test.type)
  PROC check.string (VAL []BYTE val1, val2, VAL []BYTE test.type)
    INT key:
    IF
      (SIZE val1) <> (SIZE val2)
        SEQ
          failed.test (test.type)
          writes (" string size mismatch")
          in (key)
          error.count := error.count + 1
      IF i = 0 FOR SIZE val1
        val1[i] <> val2[i]
          SEQ
            failed.test (test.type)
            writes (" strings not equal")
            in (key)
            error.count := error.count + 1
      TRUE
        completed.ok (test.type)
  :
  --}}}
  --}}}
  --{{{  set up bits.per.word
  INT any :
  VAL []BYTE b RETYPES any :
  VAL bits.per.word IS (SIZE b) * 8 :
  --}}}
  SEQ
    init ("CG test 19", "Predefines")
    --{{{  test predefines             (F500 - F699)
    PROC predefines()
      SEQ
        --{{{  output message
        title ("Testing predefined functions")
        --}}}
        --{{{  LONGADD                     (F500 - F509)
        --{{{  constants
        VAL n1 IS 10 :
        VAL n2 IS 15 :
        VAL n3 IS 25 :
        VAL n4 IS 26 :
        VAL c0 IS 0 :
        VAL c1 IS 1 :
        --}}}
        INT a, b, c :
        SEQ
          check (LONGADD (n1, n2, c0), n3, "F500")
          check (LONGADD (n1, n2, c1), n4, "F501")
          b , c := id(n1), id(n2)
          a := LONGADD (b, c, 7)
          check (a, n4, "F502")
          a := LONGADD (b, c, 8)
          check (a, n3, "F503")
          a := LONGADD (10, LONGADD (b, c, 0), c1)
          check (a, 36, "F504")
          a := LONGADD (LONGADD (b, c, c0), LONGADD (b, c, c1), LONGADD (b, c, 0))
          check (a, 52, "F505")
          b , c := -1, -1
          check (LONGADD (b, c, 0), -2, "F506")
          check (LONGADD (b, c, 1), -1, "F507")
        --}}}
        --{{{  LONGSUM                     (F510 - F519)
        --{{{  constants
        VAL n1 IS 10 :
        VAL n2 IS 15 :
        VAL n3 IS 25 :
        VAL n4 IS 26 :
        VAL c0 IS 0 :
        VAL c1 IS 1 :
        --}}}
        INT sum, b, c, carry :
        SEQ
          b , c := id(n1), id(n2)
          carry , sum := LONGSUM (b, c, 7)
          check (sum,  n4, "F510")
          check (carry, 0, "F511")
          carry , sum := LONGSUM (b, c, 8)
          check (sum,  n3, "F512")
          check (carry, 0, "F513")
          carry , sum := LONGSUM (b, c, c1)
          check (sum,  26, "F514")
          check (carry, 0, "F515")
          b , c := -1, 1     -- b is all 1s
          carry , sum := LONGSUM (b, c, 0)
          check (sum,   0, "F516")
          check (carry, 1, "F517")
          carry , sum := LONGSUM (b, c, 1)
          check (sum,   1, "F518")
          check (carry, 1, "F519")
          b , c := -1, -1     -- b & c are all 1s
          carry , sum := LONGSUM (b, c, 0)
          check (sum,   -2, "F519a")
          check (carry,  1, "F519b")
          carry , sum := LONGSUM (b, c, 1)
          check (sum,   -1, "F519c")
          check (carry,  1, "F519d")
          b, c := 1, 2
          carry , sum := LONGSUM (LONGADD(b, c, 0), LONGADD(0, -b, 0), LONGADD(b, c, 0))
          check (sum,   3, "F519e")
          check (carry, 1, "F519f")
        --}}}
        --{{{  LONGSUB                     (F520 - F529)
        INT diff, x, y, b :
        SEQ
          check (LONGSUB (10, 5, 0), 5, "F520")
          check (LONGSUB (10, 5, 1), 4, "F521")
          x, y, b := 10, 5, 0
          check (LONGSUB (x, y, b), 5, "F522")
          check (LONGSUB (x, y, b + 1), 4, "F523")
          diff := LONGSUB (x, y, b + 1)
          check (diff, 4, "F524")
          diff := LONGSUB (LONGSUB (x * 2, y, 0), LONGSUB (x, y, 1), LONGSUB (x, x, b))
          check (diff, 11, "F525")
          x, y, b := MOSTPOS INT, 0, 1
          check (LONGSUB (x, y, b), (MOSTPOS INT) - 1, "F526")
          check (LONGSUB (x, y, 0), MOSTPOS INT      , "F527")
          x, y, b := (MOSTNEG INT) + 1, 1, 0
          check (LONGSUB (x, y, b), MOSTNEG INT, "F528")
          -- Check negative values
          check (LONGSUB (1, -1, 0), 2, "F529")
        --}}}
        --{{{  LONGDIFF                    (F530 - F539)
        INT diff, borrow, x, y, b :
        SEQ
          borrow, diff := LONGDIFF (10, 5, 0)
          check (diff,   5, "F530")
          check (borrow, 0, "F531")
          borrow, diff := LONGDIFF (10, 5, 1)
          check (diff,   4, "F532")
          check (borrow, 0, "F533")
          x, y, b := 10, 5, 0
          borrow, diff := LONGDIFF (x, y, b)
          check (diff,   5, "F534")
          check (borrow, 0, "F535")
          borrow, diff := LONGDIFF (0, 1, 0)
          check (diff,  -1, "F536")
          check (borrow, 1, "F537")
          borrow, diff := LONGDIFF (MOSTNEG INT, MOSTPOS INT, 0)
          check (diff,   1, "F538")
          check (borrow, 0, "F539")
          -- Complex exp and negative
          borrow, diff := LONGDIFF (-1, -1, 0)
          check (diff,   0, "F539a")
          check (borrow, 0, "F539b")
          borrow, diff := LONGDIFF (-1, -1, 0)
          check (diff,   0, "F539c")
          check (borrow, 0, "F539d")
          x, y, b := 42, 15, 0
          borrow, diff := LONGDIFF(LONGSUB(x, y, b),
                                   LONGSUB(x, y, b+1), LONGSUB(x, y, 1))
          check(diff,    1, "F539e")
          check(borrow,  0, "F539f")
        --}}}
        --{{{  LONGPROD                    (F540 - F549)
        INT hi, lo, x, y, c :
        SEQ
          hi, lo := LONGPROD (150, 3, 5)
          check (hi, 0, "F540")
          check (lo, 455, "F541")
          hi, lo := LONGPROD (MOSTNEG INT, 2, 57)
          check (hi, 1, "F542")
          check (lo, 57, "F543")
          -- Complex parameters
          x, y, c := 1, 2, 3
          hi, lo := LONGPROD (c / (x+y), x+(y+c), (x*y) + c)
          check(hi,  0, "F544")
          check(lo, 11, "F545")
        --}}}
        --{{{  LONGDIV                     (F550 - F559)
        INT q, r, hi, lo, d :
        SEQ
          q, r := LONGDIV (0, 10, 3)
          check (q, 3, "F550")
          check (r, 1, "F551")
          hi, lo, d := 1, 1, 2
          q, r := LONGDIV (hi, lo, d)
          check (q, MOSTNEG INT, "F552")
          check (r, 1, "F553")
          q, r := LONGDIV (256, 42, 512)
          check (q, MOSTNEG INT, "F554")
          check (r, 42, "F555")
          -- Complex parameters
          hi, lo, d := id(#100), id(42), id(#1000)
          q, r := LONGDIV(hi + (hi >> 16), lo + (lo >> 16), d /\ (d \/ lo))
          check (q, (MOSTNEG INT) >> 3, "F556")
          check (r, lo, "F557")
        --}}}
        --{{{  SHIFTRIGHT                  (F560 - F569)
        INT hi, lo, hi.in, lo.in, p :
        SEQ
          hi, lo := SHIFTRIGHT (5, 0, 1)
          check (hi, 2, "F560")
          check (lo, MOSTNEG INT, "F561")
          hi.in, lo.in, p := 21, 3, 3
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 2, "F562")
          check (lo, (MOSTNEG INT) \/ ((MOSTNEG INT) >> 2), "F563")
          hi.in, lo.in, p := 0, 127, 8
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 0, "F564")
          check (lo, 0, "F565")
          hi.in, lo.in, p := 3, 3, 1
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 1, "F566")
          check (lo, (MOSTNEG INT) \/ 1, "F567")
          hi.in, lo.in, p := 5643, 5434, 0
          hi, lo := SHIFTRIGHT (hi.in, lo.in, p)
          check (hi, 5643, "F568")
          check (lo, 5434, "F569")
          -- Complex args
          hi.in, lo.in, p := id(-1), id(42), id(4)
          hi, lo := SHIFTRIGHT(hi.in + (p - (lo.in / 10)), (hi.in + lo.in) + (p/4),
                               (hi.in \/ 2) /\ p)
          check(hi, (MOSTPOS INT) >< (7 << (bits.per.word - 4)), "F569a")
          check(lo, (15 << (bits.per.word - 4)) \/ 2, "F569b")
        --}}}
        --{{{  SHIFTLEFT                   (F570 - F579)
        INT hi, lo, hi.in, lo.in, p :
        SEQ
          hi, lo := SHIFTLEFT (1, (MOSTNEG INT) + 1, 1)
          check (hi, 3, "F570")
          check (lo, 2, "F571")
          hi.in, lo.in, p := 7, (MOSTNEG INT) + 5, 2
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 30, "F572")
          check (lo, 20, "F573")
          hi.in, lo.in, p := MOSTNEG INT, MOSTNEG INT, 1
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 1, "F574")
          check (lo, 0, "F575")
          hi.in, lo.in, p := 1, 1, 8
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 256, "F576")
          check (lo, 256, "F577")
          hi.in, lo.in, p := 5643, 5434, 0
          hi, lo := SHIFTLEFT (hi.in, lo.in, p)
          check (hi, 5643, "F578")
          check (lo, 5434, "F579")
          -- Complex args
          hi.in, lo.in, p := -1, 42, 4
          hi, lo := SHIFTLEFT(hi.in + (p - (lo.in / 10)), (hi.in + lo.in) + (p/4),
                              (hi.in \/ 2) /\ p)
          check(hi, (MOSTPOS INT) << 4, "F579a")
          check(lo, 42 * 16, "F579b")
        --}}}
        --{{{  NORMALISE                   (F580 - F589)
        INT p, hi, lo, hi.in, lo.in :
        SEQ
          p, hi, lo := NORMALISE (MOSTPOS INT, MOSTNEG INT)
          check (p, 1, "F580")
          check (hi, -1, "F581")
          check (lo, 0, "F582")
          hi.in, lo.in := (MOSTPOS INT) >> 2, 3
          p, hi, lo := NORMALISE (hi.in, lo.in)
          check (p, 3, "F583")
          check (hi, -8, "F584")
          check (lo, 24, "F585")
          hi.in, lo.in := 0, 0
          p, hi, lo := NORMALISE (hi.in, lo.in)
          check (p, bits.per.word * 2, "F586")
          check (hi \/ lo, 0, "F587")     -- check they're both zero
        --}}}
        --{{{  ASHIFTRIGHT                 (F590 - F599)
        INT n, x, p :
        SEQ
          check (ASHIFTRIGHT (-1, 1), -1, "F590")
          n := ASHIFTRIGHT (-2, 1)
          check (n, -1, "F591")
          x, p := -4, 2
          check (ASHIFTRIGHT (x, p), -1, "F592")
          n := ASHIFTRIGHT (x, p)
          check (n, -1, "F593")
          x, p := -20, 2
          n := ASHIFTRIGHT (x, p)
          check (n, -5, "F594")
          x, p := 10, 3
          check (ASHIFTRIGHT (x, p), 1, "F595")
          x, p := MOSTPOS INT, 1
          check (ASHIFTRIGHT (x, p), (MOSTPOS INT) >> 1, "F596")
          x, p := MOSTNEG INT, 1
          check (ASHIFTRIGHT (x, p), ((MOSTNEG INT) >> 1) \/ (MOSTNEG INT), "F597")
          x, p := 12345, 0
          check (ASHIFTRIGHT (x, p), 12345, "F598")
        --}}}
        --{{{  ASHIFTLEFT                  (F600 - F609)
        INT n, x, p :
        SEQ
          check (ASHIFTLEFT (-7, 2), -28, "F600")
          check (ASHIFTLEFT ( 7, 2),  28, "F601")
          n := ASHIFTLEFT (256, 3)
          check (n, 2048, "F602")
          x, p := (MOSTPOS INT) >> 1, 1
          check (ASHIFTLEFT (x, p), (MOSTPOS INT) - 1, "F603")
          x, p := (MOSTNEG INT) >> 6, 5
          check (ASHIFTLEFT (x, p), (MOSTNEG INT) >> 1, "F604")
          SEQ i = -15 FOR 30
            IF
              ASHIFTLEFT (i, 2) = (i * 4)
                SKIP
              TRUE
                check (i, 10000, "F605")
          x, p := 12345, 0
          check (ASHIFTLEFT (x, p), 12345, "F606")
        --}}}
        --{{{  ROTATERIGHT                 (F610 - F619)
        INT n, x, p :
        SEQ
          check (ROTATERIGHT (15, 1), (MOSTNEG INT) \/ 7, "F610")
          x, p := 15, 1
          check (ROTATERIGHT (x, p), (MOSTNEG INT) \/ 7, "F611")
          x, p := 12345, 0
          check (ROTATERIGHT (x, p), 12345, "F612")
          x, p := 1, 2
          check (ROTATERIGHT (x, p), (MOSTNEG INT) >> 1, "F613")
          x, p := (MOSTNEG INT) + 5, 1
          check (ROTATERIGHT (x, p), ((MOSTNEG INT) >> 1) \/ ((MOSTNEG INT) \/ 2),
                 "F614")
          x, p := MOSTNEG INT, bits.per.word
          check (ROTATERIGHT (x, p), MOSTNEG INT, "F615")
          x, p := MOSTPOS INT, bits.per.word - 1
          check (ROTATERIGHT (x, p), -2, "F616")
        --}}}
        --{{{  ROTATELEFT                  (F620 - F629)
        INT n, x, p :
        SEQ
          check (ROTATELEFT (15, 1), 30, "F620")
          x, p := 15, 1
          check (ROTATELEFT (x, p), 30, "F621")
          x, p := 12345, 0
          check (ROTATELEFT (x, p), 12345, "F622")
          x, p := (MOSTNEG INT) >> 1, 2
          check (ROTATELEFT (x, p), 1, "F623")
          x, p := (MOSTNEG INT) + 5, 1
          check (ROTATELEFT (x, p), 11, "F624")
          x, p := MOSTNEG INT, bits.per.word
          check (ROTATELEFT (x, p), MOSTNEG INT, "F625")
          x, p := -2, bits.per.word - 1
          check (ROTATELEFT (x, p), MOSTPOS INT, "F626")
        --}}}
        --{{{  nested calls                (F640 - F649)
        INT a, b, c, d, e, f, x :
        SEQ
          a, b, c, d, e, f := 1, 2, 3, 4, 5, 6
          x := LONGADD (LONGADD (a, b, c), LONGADD (d, e, f), LONGADD (a, b, c))
          check (x, 13, "F640")
          x := LONGADD (LONGADD (a, a+a, b+a),
                        LONGADD (d*a, (a*c)+(a+a), f),
                        LONGADD (a, b, (c+a)+e))
          check (x, 13, "F641")
          x := 13
          SEQ i = 0 FOR 10
            x := ASHIFTRIGHT (ASHIFTLEFT (ASHIFTRIGHT (ASHIFTLEFT (x, i), i), i), i)
          check (x, 13, "F642")
          x := 42
          SEQ i = 0 FOR bits.per.word
            x := ROTATELEFT (ROTATERIGHT (ROTATELEFT (ROTATERIGHT (x, i), i), i), i)
          check (x, 42, "F643")
          x := 0
          SEQ i = 0 FOR 10
            x := LONGADD (x, i, i)
          check (x, 50, "F644")
        --}}}
        --{{{  REAL32OP and REAL64OP       (F650 - F669)
        --{{{  REAL32OP                    (F650 - F659)
        REAL32 x, y :
        INT z :
        SEQ
          -- NOTE - 0=ADD, 1=SUB, 2=MUL, 3=DIV
          x, y := 42.0(REAL32), 13.0(REAL32)
          check (INT TRUNC REAL32OP (13.0(REAL32), 0, 57.0(REAL32)), 70,"F650")
          check (INT TRUNC REAL32OP (x, 0, y), 55, "F651")
          check (INT TRUNC REAL32OP (x, 1, y), 29, "F652")
          check (INT TRUNC REAL32OP (x, 2, y), 546, "F653")
          check (INT TRUNC REAL32OP (x, 3, y), 3, "F654")
          z := INT TRUNC REAL32OP (x, 0, y)
          check (z, 55, "F655")
          z := INT TRUNC REAL32OP (x, 1, y)
          check (z, 29, "F656")
          z := INT TRUNC REAL32OP (x, 2, y)
          check (z, 546, "F657")
          z := INT TRUNC REAL32OP (x, 3, y)
          check (z, 3, "F658")
        --}}}
        --{{{  REAL64OP                    (F660 - F669)
        REAL64 x, y :
        INT z :
        SEQ
          -- NOTE - 0=ADD, 1=SUB, 2=MUL, 3=DIV
          x, y := 42.0(REAL64), 13.0(REAL64)
          check (INT TRUNC REAL64OP (13.0(REAL64), 0, 57.0(REAL64)), 70,"F660")
          check (INT TRUNC REAL64OP (x, 0, y), 55, "F661")
          check (INT TRUNC REAL64OP (x, 1, y), 29, "F662")
          check (INT TRUNC REAL64OP (x, 2, y), 546, "F663")
          check (INT TRUNC REAL64OP (x, 3, y), 3, "F664")
          z := INT TRUNC REAL64OP (x, 0, y)
          check (z, 55, "F665")
          z := INT TRUNC REAL64OP (x, 1, y)
          check (z, 29, "F666")
          z := INT TRUNC REAL64OP (x, 2, y)
          check (z, 546, "F667")
          z := INT TRUNC REAL64OP (x, 3, y)
          check (z, 3, "F668")
        --}}}
        --}}}
        --{{{  ASSERT                      (F700 - F799)
        PROC test.ASSERTions()
          SEQ
            --{{{  test.ASSERT       (F700 - F719)
            PROC test.ASSERT(VAL BOOL true, false, true1, true2, false1, false2)
              SEQ
                ASSERT(true)
                check.BOOL(true, TRUE, "F700")
                ASSERT(NOT false)
                check.BOOL(false, FALSE, "F701")
                ASSERT(true AND true1)
                check.BOOL(true, TRUE, "F702")
                ASSERT(true AND true1 AND true2)
                check.BOOL(true, TRUE, "F703")
                ASSERT(false OR true)
                check.BOOL(true, TRUE, "F704")
                ASSERT(true OR false)
                check.BOOL(true, TRUE, "F705")
                ASSERT(true OR false OR false1 OR false2)
                check.BOOL(true, TRUE, "F706")
                ASSERT(false OR false1 OR false2 OR true)
                check.BOOL(true, TRUE, "F707")
                ASSERT(NOT (NOT true))
                check.BOOL((true OR false), TRUE, "F708")
                ASSERT(NOT (NOT (NOT false)))
                check.BOOL((true OR false), TRUE, "F709")
                ASSERT(true AND (NOT false))
                check.BOOL(true, TRUE, "F710")
                ASSERT((NOT false) AND true)
                check.BOOL((NOT false), TRUE, "F711")
            :
            test.ASSERT(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)
            --}}}
            --{{{  test.IF.STOP      (F720 - F739)
            PROC test.IF.STOP (VAL BOOL true, false, true1, true2, false1, false2)
              SEQ
                IF
                  NOT true
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F720")
                IF
                  false
                    STOP
                  TRUE
                    SKIP
                check.BOOL(false, FALSE, "F721")
                IF
                  NOT (true AND true1)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F722")
                IF
                  NOT (true AND true1 AND true2)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F723")
                IF
                  NOT (false OR true)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F724")
                IF
                  NOT (true OR false)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F725")
                IF
                  NOT (true OR false OR false1 OR false2)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F726")
                IF
                  NOT (false OR false1 OR false2 OR true)
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F727")
                IF
                  NOT (NOT (NOT true))
                    STOP
                  TRUE
                    SKIP
                check.BOOL((true OR false), TRUE, "F728")
                IF
                  (NOT (NOT false))
                    STOP
                  TRUE
                    SKIP
                check.BOOL((true OR false), TRUE, "F729")
                IF
                  NOT (true AND (NOT false))
                    STOP
                  TRUE
                    SKIP
                check.BOOL(true, TRUE, "F730")
                IF
                  NOT ((NOT false) AND true)
                    STOP
                  TRUE
                    SKIP
                check.BOOL((NOT false), TRUE, "F731")
            :
            test.IF.STOP(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)
            --}}}
            --{{{  test.IF.SKIP      (F740 - F759)
            PROC test.IF.SKIP(VAL BOOL true, false, true1, true2, false1, false2)
              SEQ
                IF
                  (true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F740")
                IF
                  (NOT false)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(false, FALSE, "F741")
                IF
                  (true AND true1)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F742")
                IF
                  (true AND true1 AND true2)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F743")
                IF
                  (false OR true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F744")
                IF
                  (true OR false)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F745")
                IF
                  (true OR false OR false1 OR false2)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F746")
                IF
                  (false OR false1 OR false2 OR true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F747")
                IF
                  (NOT (NOT true))
                    SKIP
                  TRUE
                    STOP
                check.BOOL((true OR false), TRUE, "F748")
                IF
                  (NOT (NOT (NOT false)))
                    SKIP
                  TRUE
                    STOP
                check.BOOL((true OR false), TRUE, "F749")
                IF
                  (true AND (NOT false))
                    SKIP
                  TRUE
                    STOP
                check.BOOL(true, TRUE, "F750")
                IF
                  ((NOT false) AND true)
                    SKIP
                  TRUE
                    STOP
                check.BOOL((NOT false), TRUE, "F751")
            :
            test.IF.SKIP(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)
            --}}}
            --{{{  test.local.ASSERT (F760 - F779)
            PROC test.local.ASSERT(VAL BOOL true, false, true1, true2, false1, false2)
              PROC ASSERT(VAL BOOL test)
                check.BOOL(test, TRUE, "F779")
              :
              SEQ
                ASSERT(true)
                check.BOOL(true, TRUE, "F760")
                ASSERT(NOT false)
                check.BOOL(false, FALSE, "F761")
                ASSERT(true AND true1)
                check.BOOL(true, TRUE, "F762")
                ASSERT(true AND true1 AND true2)
                check.BOOL(true, TRUE, "F763")
                ASSERT(false OR true)
                check.BOOL(true, TRUE, "F764")
                ASSERT(true OR false)
                check.BOOL(true, TRUE, "F765")
                ASSERT(true OR false OR false1 OR false2)
                check.BOOL(true, TRUE, "F766")
                ASSERT(false OR false1 OR false2 OR true)
                check.BOOL(true, TRUE, "F767")
                ASSERT(NOT (NOT true))
                check.BOOL((true OR false), TRUE, "F768")
                ASSERT(NOT (NOT (NOT false)))
                check.BOOL((true OR false), TRUE, "F769")
                ASSERT(true AND (NOT false))
                check.BOOL(true, TRUE, "F770")
                ASSERT((NOT false) AND true)
                check.BOOL((NOT false), TRUE, "F771")
            :
            test.local.ASSERT(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)
            --}}}
        :
        test.ASSERTions()
        --}}}
    :
    predefines()
    --}}}
    --{{{  floating point 32
    PROC floating.point32()
      REAL32 i32, j32, r32 :
      INT i :
      BOOL b :
      INT32 int32 :
      SEQ
        i32 := 1.1(REAL32)
        j32 := -1.1(REAL32)
        check.REAL32(ABS(i32), 1.1(REAL32), "F1001")
        check.REAL32(ABS(j32), 1.1(REAL32), "F1002")
        check.REAL32(SQRT(i32), 1.048808848(REAL32), "F1003")
        check.BOOL(ISNAN(i32), FALSE, "F1004")
        check.BOOL(NOTFINITE(i32), FALSE, "F1005")
        check.REAL32(SCALEB(i32, 2),  4.4(REAL32), "F1006")
        check.REAL32(SCALEB(j32, 2), -4.4(REAL32), "F1007")
        check.REAL32(LOGB(i32), 0.0(REAL32), "F1008")
        i, r32 := FLOATING.UNPACK(i32)
        check(i, 0, "F1009")
        check.REAL32(r32, 1.1(REAL32), "F1010")
        check.REAL32(MINUSX(i32), -1.1(REAL32), "F1011")
        check.REAL32(MINUSX(j32),  1.1(REAL32), "F1012")
        check.REAL32(MINUSX( 1.1(REAL32)), -1.1(REAL32), "F1011a")
        check.REAL32(MINUSX(-1.1(REAL32)),  1.1(REAL32), "F1012a")
        -- #IF (TARGET.BITS.PER.WORD = 32)
        check.REAL32(COPYSIGN(i32, j32), -1.1(REAL32), "F1013")
        check.REAL32(COPYSIGN(j32, i32),  1.1(REAL32), "F1014")
        -- #ENDIF
        VAL REAL32 ans RETYPES #3F8CCCCC(INT32) :
        check.REAL32(NEXTAFTER(i32, j32), ans, "F1015")
        VAL REAL32 ans RETYPES #BF8CCCCC(INT32) :
        check.REAL32(NEXTAFTER(j32, i32), ans, "F1016")
        check.BOOL(ORDERED(i32, j32), TRUE, "F1017")
        b, int32, r32 := ARGUMENT.REDUCE(i32, 3.1415927(REAL32), 1.0E-8(REAL32))
        check.BOOL(b, TRUE, "F1018")
        check.INT32(int32, 0(INT32), "F1019")
        check.REAL32(r32, 1.1(REAL32), "F1020")
        check.REAL32(MULBY2(i32), 2.2(REAL32), "F1021")
        check.REAL32(DIVBY2(i32), 0.55(REAL32), "F1022")
        check.REAL32(FPINT(i32), 1.0(REAL32), "F1023")
        -- REAL32OP is checked above
        b, r32 := IEEE32OP(i32, 0, 0, j32)
        check.BOOL(b, FALSE, "F1050")
        check.REAL32(r32, 0.0(REAL32), "F1051")
        check.REAL32(REAL32REM(i32, j32), 0.0(REAL32), "F1052")
        b, r32 := IEEE32REM(i32, j32)
        check.BOOL(b, FALSE, "F1053")
        check.REAL32(r32, 0.0(REAL32), "F1054")
        check.BOOL(REAL32EQ(i32, j32), FALSE, "F1055")
        check.BOOL(REAL32GT(i32, j32), TRUE, "F1056")
        check(IEEECOMPARE(i32, j32), 1, "F1057")
    :
    floating.point32()
    --}}}
    --{{{  floating point 64
    PROC floating.point64()
      REAL64 i64, j64, r64 :
      INT i :
      BOOL b :
      INT32 int32 :
      SEQ
        i64 := 1.1(REAL64)
        j64 := -1.1(REAL64)
        check.REAL64(DABS(i64), 1.1(REAL64), "F1101")
        check.REAL64(DABS(j64), 1.1(REAL64), "F1102")
        VAL REAL64 ans RETYPES #3FF0C7EBC96A56F6(INT64) :
        check.REAL64(DSQRT(i64), ans, "F1103")
        check.BOOL(DISNAN(i64), FALSE, "F1104")
        check.BOOL(DNOTFINITE(i64), FALSE, "F1105")
        check.REAL64(DSCALEB(i64, 2),  4.4(REAL64), "F1106")
        check.REAL64(DSCALEB(j64, 2), -4.4(REAL64), "F1107")
        check.REAL64(DLOGB(i64), 0.0(REAL64), "F1108")
        i, r64 := DFLOATING.UNPACK(i64)
        check(i, 0, "F1109")
        check.REAL64(r64, 1.1(REAL64), "F1110")
        check.REAL64(DMINUSX(i64), -1.1(REAL64), "F1111")
        check.REAL64(DMINUSX(j64),  1.1(REAL64), "F1112")
        check.REAL64(DMINUSX( 1.1(REAL64)), -1.1(REAL64), "F1111a")
        check.REAL64(DMINUSX(-1.1(REAL64)),  1.1(REAL64), "F1112a")
        check.REAL64(DCOPYSIGN(i64, j64), -1.1(REAL64), "F1113")
        check.REAL64(DCOPYSIGN(j64, i64),  1.1(REAL64), "F1114")
        VAL REAL64 ans RETYPES #3FF1999999999999(INT64) :
        check.REAL64(DNEXTAFTER(i64, j64), ans, "F1115")
        VAL REAL64 ans RETYPES #BFF1999999999999(INT64) :
        check.REAL64(DNEXTAFTER(j64, i64), ans, "F1116")
        check.BOOL(DORDERED(i64, j64), TRUE, "F1117")
        b, int32, r64 := DARGUMENT.REDUCE(i64, 3.1415927(REAL64), 1.0E-8(REAL64))
        check.BOOL(b, TRUE, "F1118")
        check.INT32(int32, 0(INT32), "F1119")
        check.REAL64(r64, 1.1(REAL64), "F1120")
        check.REAL64(DMULBY2(i64), 2.2(REAL64), "F1121")
        check.REAL64(DDIVBY2(i64), 0.55(REAL64), "F1122")
        check.REAL64(DFPINT(i64), 1.0(REAL64), "F1123")
        -- REAL64OP is checked above
        b, r64 := IEEE64OP(i64, 0, 0, j64)
        check.BOOL(b, FALSE, "F1050")
        check.REAL64(r64, 0.0(REAL64), "F1051")
        check.REAL64(REAL64REM(i64, j64), 0.0(REAL64), "F1052")
        b, r64 := IEEE64REM(i64, j64)
        check.BOOL(b, FALSE, "F1053")
        check.REAL64(r64, 0.0(REAL64), "F1054")
        check.BOOL(REAL64EQ(i64, j64), FALSE, "F1055")
        check.BOOL(REAL64GT(i64, j64), TRUE, "F1056")
        check(DIEEECOMPARE(i64, j64), 1, "F1057")
    :
    floating.point64()
    --}}}
    --{{{  PROC f ()    - check fmul
    PROC f ()
      --{{{  PROC fmul
      PROC fmul (INT a, VAL INT b, c)
        INT rlo, rhi :
        SEQ
          rhi,  rlo := LONGPROD ( b,  c,  0)
          IF
            b < 0
              rhi := rhi MINUS c
            TRUE
              SKIP
          IF
            c < 0
              rhi := rhi MINUS b
            TRUE
              SKIP
          rhi,  rlo := SHIFTLEFT ( rhi,  rlo,  1)
          IF
            rlo >= 0
              a := rhi
            --rlo <> #80000000
            rlo <> (MOSTNEG INT)
              a := rhi PLUS 1
            (rhi /\ 1) = 1
              a := rhi PLUS 1
            TRUE
              a := rhi
      :
      --}}}
      --{{{  PROC check.fmul
      PROC check.fmul (VAL INT x, y, VAL []BYTE where)
        INT v1, v2 :
        SEQ
          -- #IF NOT DEFINED (COMPILER.TOCK)
          fmul (v1, x, y)
          v2 := FRACMUL (x, y)
          check (v2, v1, where)
          -- #ENDIF
      :
      --}}}
      SEQ
        check.fmul (0, 0, "F01")
        check.fmul (1, 1, "F02")
        check.fmul (-1, 1, "F03")
        check.fmul (1, -1, "F04")
        check.fmul (-1, -1, "F05")
        -- #IF (TARGET.BITS.PER.WORD = 32)
        -- These all overflow on a T212:
        -- Commented in again (DCW)
        check.fmul (65536, 65536, "F06")
        check.fmul (-65536, 65536, "F07")
        check.fmul (65536, -65536, "F08")
        check.fmul (-65536, -65536, "F09")
        check.fmul (#12345678, #12345678, "F10")
        check.fmul (#12345678, #87654321, "F11")
        check.fmul (#87654321, #87654321, "F12")
        check.fmul (#87654321, #12345678, "F13")
        -- #ENDIF
    :
    f ()
    --}}}
    --{{{  bugs
    PROC bugs()
      SEQ
        --{{{  bug 186
        -- test for bug 186 in buglist
        VAL bpw IS ((INT ((MOSTNEG INT) =  #8000)) * 2) +
                   ((INT ((MOSTNEG INT) <> #8000)) * 4) :
        SEQ
          -- #IF NOT DEFINED (COMPILER.TOCK)
          check (BITREVNBITS(#1234, 16), #2C48, "B186a")
          VAL x IS MOSTPOS INT :
          check (BITREVNBITS(BITREVNBITS(x, bpw * 8), bpw * 8), x, "B186b")
          VAL x IS MOSTNEG INT :
          check (BITREVNBITS(BITREVNBITS(x, bpw * 8), bpw * 8), x, "B186c")
          VAL x IS 27 :
          check (BITREVNBITS(BITREVNBITS(x, bpw * 8), bpw * 8), x, "B186d")
          VAL x IS -1 :
          check (BITREVNBITS(BITREVNBITS(x, 8), 8), x /\ #FF, "B186e")
          VAL x IS -1 :
          check (BITREVNBITS(BITREVNBITS(x, 16), 16), x /\ #FFFF, "B186f")
          -- #ENDIF
        --}}}
        --{{{  bug 129
        -- test for bug 129 in buglist
        REAL32 r :
        REAL64 d :
        SEQ
          r, d := 1234.0(REAL32), 4321.0(REAL64)
          r := MINUSX(r)
          d := DMINUSX(d)
          check (INT ROUND r, -1234, "B129a")
          check (INT ROUND d, -4321, "B129b")
        --}}}
        --{{{  bug 249
        -- test for bug 249 in buglist
        BOOL b :
        SEQ
          b := ORDERED(27.0(REAL32), 27.0(REAL32))
          check (INT b, INT TRUE, "B249a")
          b := DORDERED(42.6(REAL64), 42.6(REAL64))
          check (INT b, INT TRUE, "B249b")
        --}}}
        --{{{  bug 274
        -- test for bug 274 in buglist
        REAL32 x32, y32, z32 :
        REAL64 x64, y64, z64 :
        BOOL b :
        SEQ
          x32, y32 := 10.0(REAL32), 6.0(REAL32)
          x64, y64 := 10.0(REAL64), 6.0(REAL64)
          b, z32 := IEEE32REM(x32, y32)
          b, z64 := IEEE64REM(x64, y64)
          check(INT ROUND z32, -2, "B274a")
          check(INT ROUND z64, -2, "B274b")
        --}}}
    :
    bugs()
    --}}}
    --{{{  UNPACKSN and ROUNDSN
    PROC SNstuff()
      -- Here the 32 bit constants are masked by an integer at run time. This
      -- prevents the compiler doing the conversion at compile time and complaining
      -- that they won't fit into an INT(16).
      INT frac, exp, type :
      VAL INT32 Nan IS #7FC00000(INT32) :
      VAL INT32 Inf IS #7F800000(INT32) :
      INT32 mask :
      INT a.int :
      IF
        bits.per.word = 32
          SEQ
            -- #IF NOT DEFINED (COMPILER.TOCK)
            mask := 0(INT32)
            frac, exp, type := UNPACKSN(0)
            check(type, 0, "SN0")
            frac, exp, type := UNPACKSN(5)
            check(5 << 8, frac, "TEST") -- Need to shift as result biased
            check(1,  exp, "TEST")
            check(type, 1, "SN1")
            frac, exp, type := UNPACKSN(INT (Inf \/ mask))
            check(type, 2, "SN2")
            frac, exp, type := UNPACKSN(INT (Nan \/ mask))
            check(type, 3, "SN3")
            -- #IF (TARGET.BITS.PER.WORD = 32)
            -- Sample values given in the Inmos documentation
            frac, exp, type := UNPACKSN (#40490FDB)
            check (frac, #C90FDB00, "SNI0frac")
            check (exp, #00000080, "SNI0exp")
            check (type, 1, "SNI0exp")
            frac, exp, type := UNPACKSN (#00000001)
            check (frac, #00000100, "SNI1frac")
            check (exp, #00000001, "SNI1exp")
            check (type, 1, "SNI1exp")
            frac, exp, type := UNPACKSN (#7FC00001)
            check (frac, #40000100, "SNI2frac")
            check (exp, #000000FF, "SNI2exp")
            check (type, 3, "SNI2exp")
            -- Sample values given in the Inmos documentation
            a.int := ROUNDSN (#00000080, #C90FDB00, #00000000)
            check (a.int, #40490FDB, "SNI3")
            a.int := ROUNDSN (#00000080, #C90FDB80, #00000000)
            check (a.int, #40490FDC, "SNI4")
            a.int := ROUNDSN (#00000080, #C90FDA80, #00000000)
            check (a.int, #40490FDA, "SNI5")
            a.int := ROUNDSN (#00000080, #C90FDA80, #00003000)
            check (a.int, #40490FDB, "SNI6")
            a.int := ROUNDSN (#00000001, #00000100, #00000000)
            check (a.int, #00000001, "SNI7")
            -- #ENDIF
            -- #ENDIF
        TRUE
          SKIP
    :
    SNstuff()
    --}}}
    --{{{  RESCHEDULE
    -- This should do nothing!
    PROC reschedule()
      SEQ
        RESCHEDULE()
    :
    reschedule()
    --}}}
    --{{{  CRC stuff
    PROC CRCtest()
      INT dataIn, dataOut :
      INT FUNCTION test(VAL INT data, CRCIn, generator, length)
        INT MyData, CRCOut, OldCRC :
        VALOF
          SEQ
            MyData, CRCOut := data, CRCIn
            SEQ i = 0 FOR length
              SEQ
                OldCRC := CRCOut
                CRCOut, MyData := SHIFTLEFT (CRCOut, MyData, 1)
                IF
                  OldCRC < 0 -- MSB of CRC = 1
                    CRCOut := CRCOut >< generator
                  TRUE
                    SKIP
          RESULT CRCOut
      :
      SEQ
        -- #IF NOT DEFINED (COMPILER.TOCK)
        check(CRCWORD(1234, 0, 654),    test(1234, 0, 654, bits.per.word), "CRC0")
        check(CRCWORD(1234, 0,  54),    test(1234, 0,  54, bits.per.word), "CRC1")
        check(CRCWORD(1234, 4321, 654), test(1234, 4321, 654, bits.per.word), "CRC2")
        dataIn := 56 << (bits.per.word - 8)
        check(CRCBYTE(dataIn, 0, 654),  test(dataIn, 0, 654, 8), "CRC3")
        check(CRCBYTE(dataIn, 0,  54),  test(dataIn, 0,  54, 8), "CRC4")
        check(CRCBYTE(dataIn, 4321, 654),  test(dataIn, 4321, 654, 8), "CRC5")
        -- #ENDIF
    :
    CRCtest()
    --}}}
    --{{{  Bit manipulation
    PROC bitManipulation()
      SEQ
        -- #IF NOT DEFINED (COMPILER.TOCK)
        check(BITCOUNT(0,0), 0, "BM0")
        check(BITCOUNT(1,0), 1, "BM1")
        check(BITCOUNT(#100, 0), 1, "BM2")
        check(BITCOUNT(MOSTNEG INT, 0), 1, "BM3")
        check(BITCOUNT(0,42), 42, "BM4")
        check(BITCOUNT(#555, 4), 10, "BM5")
        check(BITCOUNT(MOSTNEG INT, 42), 43, "BM6")
        check(BITREVWORD(1), MOSTNEG INT, "BM7")
        check(BITREVWORD((MOSTNEG INT) \/ 1), (MOSTNEG INT) \/ 1, "BM8")
        check(BITREVWORD(1234), 19232 << (bits.per.word - 16), "BM9")
        check(BITREVNBITS(1, 0), 0, "BM10")
        check(BITREVNBITS(1, 1), 1, "BM11")
        check(BITREVNBITS(1, 4), 8, "BM12")
        check(BITREVNBITS(1, bits.per.word), MOSTNEG INT, "BM13")
        check(BITREVNBITS(#555, 8), #AA, "BM14")
        -- #ENDIF
    :
    bitManipulation()
    --}}}
    --{{{  ROTATES
    PROC bug.INSdi02249()
      INT x, y, n, zero :
      SEQ
        zero := id(0)
        --{{{  ROTATERIGHT
        VAL start  IS 10 :
        VAL places IS  1 :
        VAL finish IS (start >> places) \/ (start << (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATERIGHT(start, n)
          check(y, 5, "di02249aa")
          y := ROTATERIGHT(x, n)
          check(y, 5, "di02249ab")
          y := ROTATERIGHT(x+x, n)
          check(y, start, "di02249ac")
          y := ROTATERIGHT(x, 2)
          check(y, 2 + (MOSTNEG INT), "di02249ad")
          y := ROTATERIGHT(x, n+n)
          check(y, 2 + (MOSTNEG INT), "di02249ae")
          y := ROTATERIGHT(x+x, 2)
          check(y, 5, "di02249af")
          y := ROTATERIGHT(x+x, n+n)
          check(y, 5, "di02249ag")
          y := ROTATERIGHT(id(x+x), id(n+n))
          check(y, 5, "di02249ah")
        --}}}
        --{{{  ROTATERIGHT
        VAL start  IS ((MOSTPOS INT) - #FF) + #AA :  -- #7FFF...AA
        VAL places IS 8 :
        VAL finish IS (start >> places) \/ (start << (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATERIGHT(start, n)
          check(y, finish, "di02249ba")
          y := ROTATERIGHT(x, n)
          check(y, finish, "di02249bb")
          y := ROTATERIGHT(x + zero, n)
          check(y, finish, "di02249bc")
          y := ROTATERIGHT(x, places)
          check(y, finish, "di02249bd")
          y := ROTATERIGHT(x, n+zero)
          check(y, finish, "di02249be")
          y := ROTATERIGHT(x+zero, places)
          check(y, finish, "di02249bf")
          y := ROTATERIGHT(x+zero, n+zero)
          check(y, finish, "di02249bg")
          y := ROTATERIGHT(id(x+zero), id(n+zero))
          check(y, finish, "di02249bh")
        --}}}
        --{{{  ROTATELEFT
        VAL start  IS 10 :
        VAL places IS 3 :
        VAL finish IS (start << places) \/ (start >> (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATELEFT(start, n)
          check(y, finish, "di02249ca")
          y := ROTATELEFT(x, n)
          check(y, finish, "di02249cb")
          y := ROTATELEFT(x + zero, n)
          check(y, finish, "di02249cc")
          y := ROTATELEFT(x, places)
          check(y, finish, "di02249cd")
          y := ROTATELEFT(x, n+zero)
          check(y, finish, "di02249ce")
          y := ROTATELEFT(x+zero, places)
          check(y, finish, "di02249cf")
          y := ROTATELEFT(x+zero, n+zero)
          check(y, finish, "di02249cg")
          y := ROTATELEFT(id(x+zero), id(n+zero))
          check(y, finish, "di02249ch")
        --}}}
        --{{{  ROTATELEFT
        VAL start  IS ((MOSTPOS INT) - #FF) + #AA :  -- #7FFF...AA
        VAL places IS 8 :
        VAL finish IS (start << places) \/ (start >> (bits.per.word - places)) :
        SEQ
          x := id(start)
          n := id(places)
          y := ROTATELEFT(start, n)
          check(y, finish, "di02249da")
          y := ROTATELEFT(x, n)
          check(y, finish, "di02249db")
          y := ROTATELEFT(x + zero, n)
          check(y, finish, "di02249dc")
          y := ROTATELEFT(x, places)
          check(y, finish, "di02249dd")
          y := ROTATELEFT(x, n+zero)
          check(y, finish, "di02249de")
          y := ROTATELEFT(x+zero, places)
          check(y, finish, "di02249df")
          y := ROTATELEFT(x+zero, n+zero)
          check(y, finish, "di02249dg")
          y := ROTATELEFT(id(x+zero), id(n+zero))
          check(y, finish, "di02249dh")
        --}}}
    :
    bug.INSdi02249()
    --}}}
    --{{{  Bug 297
    PROC bug.297()
      [2][5][7]BYTE patterns, screens :
      PROC init.stuff ()
        SEQ i = 0 FOR SIZE screens
          SEQ j = 0 FOR SIZE screens [0]
            SEQ k = 0 FOR SIZE screens [0][0]
              SEQ
                screens [i][j][k] := BYTE 99
                patterns[i][j][k] := BYTE (i + (j + k))
      :
      PROC check.stuff (VAL BOOL clipping, VAL []BYTE str)
        SEQ
          -- first check that the move was done OK
          IF
            IF j = 0 FOR SIZE screens[1]
              IF k = 0 FOR SIZE screens [1][0]
                IF
                  clipping AND (screens[1][j][k] <> (BYTE 99))
                    check (INT screens [1][j][k], 99, str)
                  (NOT clipping) AND (screens[0][j][k] <> (BYTE (1 + (j + k))))
                    check (INT screens [1][j][k], 1 + (j + k), str)
            TRUE
              check(1, 1, str)
          -- now check that it didn't move anything it shouldn't have
          IF
            IF j = 0 FOR SIZE screens[0]
              IF k = 0 FOR SIZE screens [0][0]
                IF
                  screens[0][j][k] <> (BYTE 99)
                    check (INT screens [0][j][k], 99, str)
                  IF i = 0 FOR SIZE patterns
                    patterns[i][j][k] <> (BYTE (i + (j + k)))
                      check(INT patterns[i][j][k], i + (j + k), str)
            TRUE
              check(3, 3, str)
      :
      INT sx, sy, dx, dy, l, w, zero, one :
      SEQ
        sx, sy, dx, dy, l, w, zero, one := 0, 0, 0, 0, 5, 7, 0, 1
        -- init.stuff ()
        -- MOVE2D (patterns[one], sx, sy, screens[one], dx, dy, w, l)
        -- check.stuff (FALSE, "B297a")
        -- MOVE2D (patterns[zero], sx, sy, screens[one], dx, dy, zero, zero) -- nothing moved
        -- check.stuff (FALSE, "B300a")
        -- init.stuff ()
        -- MOVE2D (patterns[1], 0, 0, screens[1], 0, 0, 7, 5)
        -- check.stuff (FALSE, "B297b")
        -- MOVE2D (patterns[0], 0, 0, screens[1], 0, 0, 0, 0) -- nothing moved
        -- check.stuff (FALSE, "B300b")
        -- init.stuff ()
        -- DRAW2D (patterns[one], sx, sy, screens[one], dx, dy, w, l)
        -- check.stuff (FALSE, "B297c") -- none of the source was zero, so all is moved
        -- DRAW2D (patterns[zero], sx, sy, screens[one], dx, dy, zero, zero) -- nothing moved
        -- check.stuff (FALSE, "B300c")
        -- init.stuff ()
        -- DRAW2D (patterns[1], 0, 0, screens[1], 0, 0, 7, 5)
        -- check.stuff (FALSE, "B297d") -- none of the source was zero, so all is moved
        -- DRAW2D (patterns[0], 0, 0, screens[1], 0, 0, 0, 0) -- nothing moved
        -- check.stuff (FALSE, "B300d")
        -- init.stuff ()
        -- CLIP2D (patterns[one], sx, sy, screens[one], dx, dy, w, l)
        -- check.stuff (TRUE, "B297e") -- none of the source was zero, so none is moved
        -- CLIP2D (patterns[zero], sx, sy, screens[one], dx, dy, zero, zero) -- nothing moved
        -- check.stuff (TRUE, "B300e")
        -- init.stuff ()
        -- CLIP2D (patterns[1], 0, 0, screens[1], 0, 0, 7, 5)
        -- check.stuff (TRUE, "B297f") -- none of the source was zero, so none is moved
        -- CLIP2D (patterns[0], 0, 0, screens[1], 0, 0, 0, 0) -- nothing moved
        -- check.stuff (TRUE, "B300f")
    :
    bug.297()
    --}}}
    --{{{  bug 1308
    PROC bug.1308()
      [10]INT data :
      [10][10]BYTE dest :
      [10][SIZE dest][SIZE dest[0]]BYTE source :
      INT c :
      SEQ
        SEQ i = 0 FOR SIZE data
          data [i] := i
        SEQ i = 0 FOR SIZE source[0][0]
          source[0][0][i] := BYTE i
        SEQ j = 1 FOR (SIZE source[0]) - 1
          source[0][j] := source[0][0]
        SEQ k = 1 FOR (SIZE source) - 1
          source[k] := source[0]
        c := 5
        -- MOVE2D(source[data[c]], 0, 0, dest, 0, 0, SIZE dest, SIZE dest[0])
        -- IF
        --   IF i = 0 FOR SIZE dest
        --     IF j = 0 FOR SIZE dest[0]
        --       (INT dest[i][j]) <> j
        --         check(INT dest[i][j], j, "B1308a")
        --   TRUE
        --     SKIP
    :
    bug.1308()
    --}}}
    --{{{  bug 1378
    PROC bug.1378()
      INT A, B:
      SEQ
        -- #IF NOT DEFINED (COMPILER.TOCK)
        --{{{  modified by frmb.  can't test like this, need flow-control info
        --ASM
        --  LDAB 1, 2
        --  CJ   :L1
        --  :L1
        --  ST   A
        --  LDAB 0, 1
        --  CJ   :L2
        --  :L2
        --  ST   B
        SKIP
        --}}}
        check(A, 2, "B1378a")
        check(B, 0, "B1378b")
        -- #ENDIF
    :
    bug.1378()
    --}}}
    --{{{  bug 1797 (WSSIZEOF and VSSIZEOF)
    PROC bug.1797()
      PROC test()
        SKIP
      :
      VAL slots IS 10 :
      PROC testv(VAL [slots]INT s)
        [slots]INT b :
        -- PLACE b IN VECSPACE :
        SEQ
          b := s
      :
      PROC testw(VAL [slots]INT s)
        [slots]INT b :
        -- PLACE b IN WORKSPACE :
        SEQ
          b := s
      :
      INT FUNCTION f() IS 99 :
      INT x :
      SEQ
        -- #IF NOT DEFINED (COMPILER.TOCK)
        x := WSSIZEOF(check)
        x := WSSIZEOF(finish) + x
        --x := WSSIZEOF(cg.exit) + x
        x := WSSIZEOF(f) + x
        check(INT (x > 0), INT TRUE, "B1797a")
        x := WSSIZEOF(test)
        check(INT (x < 5), INT TRUE, "B1797b")
        x := VSSIZEOF(test)
        check(x, 0, "B1797c")
        x := VSSIZEOF(testv)
        check(INT (x >= slots), INT TRUE, "B1797d")
        x := VSSIZEOF(testw)
        check(x, 0, "B1797e")
        x := WSSIZEOF(testw)
        check(INT (x >= slots), INT TRUE, "B1797f")
        -- #ENDIF
    :
    bug.1797()
    --}}}
    finish ()
:
