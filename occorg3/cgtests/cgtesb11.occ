-- version control marker $Id: cgtest11.occ,v 1.4 1995/10/10 12:57:33 djb1 Exp $
PROC cgtest11 (CHAN OF BYTE keyb, scr, err)
  --{{{  cgmain.occ
  -- version control marker $Id: cgmain.occ,v 3.9 1997/03/06 16:36:15 dcw Exp $
  --{{{  cglib.occ
  -- version control marker $Id: cglib.occ,v 1.6 1997/01/30 12:31:09 dcw Exp $
  --
  -- Cut-down version of the output utilities from the course library
  --{{{  some constants
  VAL BYTE BELL IS 7(BYTE):
  VAL BYTE NULL IS 0(BYTE):
  VAL BYTE BACK IS 8(BYTE):
  VAL BYTE DELETE IS 127(BYTE):
  --}}}
  --{{{  out stuff
  PROC out.repeat (VAL BYTE ch,  VAL INT n,  CHAN OF BYTE out)
    --{{{
    IF
      n > 0
        SEQ i = 0 FOR n
          SEQ
            out ! ch
      TRUE
        SKIP
    --}}}
  :
  PROC out.ch (VAL BYTE ch,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    SEQ
      out.repeat (' ', field - 1, out)
      out ! ch
    --}}}
  :
  PROC out.ch.funny (VAL BYTE ch,  VAL INT field,  CHAN OF [1]BYTE out)
    --{{{
    SEQ
      VAL [1]BYTE thing RETYPES ch:
      out ! thing
    --}}}
  :
  PROC out.nl (CHAN OF BYTE out)
    SEQ
      out ! '*c'
      out ! '*n'
  :
  PROC in.ch (BYTE ch, CHAN OF BYTE in)
    --{{{
    in ? ch
    --}}}
  :
  PROC out.bell (CHAN OF BYTE out)
    --{{{
    out.ch (BELL, 1, out)
    --}}}
  :
  PROC out.string (VAL []BYTE s,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    VAL length IS SIZE s:
    SEQ
      out.repeat (' ', field - length, out)
      SEQ i = 0 FOR length
        SEQ
          out ! s [i]
    --}}}
  :
  PROC out.number (VAL INT n,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    VAL max.digits IS 20:
    [max.digits]INT D:
    INT x, i:
    IF
      (n = 0)
        --{{{  zero
        SEQ
          IF
            (1 < field)
              out.repeat (' ', field - 1, out)
            (TRUE)
              SKIP
          out ! '0'
        --}}}
      (TRUE)
        SEQ
          i := 0     --  bring this line up here,   Vedat
          --{{{  check negative
          IF
            (n < 0)
              SEQ        -- this one can handle MOSTNEG INT as well
                D [i] := -(n\10)
                x := -(n/10)
                i:= i + 1
            (TRUE)         -- (n > 0)
              x := n
          --}}}
          --{{{  decompose
          -- i := 0   -- this line goes up in order to handle MOSTNEG INT
          WHILE x > 0
            SEQ
              D [i] := x\10
              x := x/10
              i := i + 1
          --}}}
          --{{{  pad
          IF
            (n > 0)
              out.repeat (' ', field - i, out)
            (TRUE)
              SEQ
                out.repeat (' ', (field - 1) - i, out)
                out ! '-'
          --}}}
          --{{{  output
          WHILE i > 0
            SEQ
              i := i - 1
              out ! BYTE (D [i] + (INT '0'))
          --}}}
    --}}}
  :
  PROC out.bool (VAL BOOL b,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    IF
      (b = TRUE)
        out.ch ('1', field, out)
      (b = FALSE)
        out.ch ('0', field, out)
      (TRUE)
        out.ch ('.', field, out)
    --}}}
  :
  PROC out.yes.no (VAL BOOL b,  VAL INT field,  CHAN OF BYTE out)
    --{{{
    IF
      b
        out.string ("yes", field, out)
      TRUE
        out.string ("no", field, out)
    --}}}
  :
  PROC out.hex.int (VAL INT x, l, CHAN OF BYTE out)
    --{{{  body of cg.write.hex.int
    -- this procedure ignores the field length parameter 'l'
    -- independent of endianism - DCW
    VAL INT nibble          IS #F:
    VAL INT hex.dig.per.int IS 8:
    VAL INT bit.per.hex.dig IS 4:
    VAL hex.dig             IS "0123456789ABCDEF":
    INT digit, mask, shift:
    [12]BYTE s:
    SEQ
      s[0]:= '#'
      SEQ i = 1 FOR hex.dig.per.int
        SEQ
          shift :=  (hex.dig.per.int - i) * bit.per.hex.dig
          digit := (x >> shift) /\ nibble
          s[i]:= hex.dig[digit]
      out.string ([s FROM 0 FOR (hex.dig.per.int + 1)], 0, out)
    --}}}
  :
  PROC black.hole (CHAN OF BYTE in)
    --{{{
    WHILE TRUE
      BYTE any:
      in ? any
    --}}}
  :
  --}}}
  --}}}
  VAL display.names  IS TRUE :
  --VAL display.names  IS TRUE :
  --VAL display.titles IS display.names :
  VAL display.titles IS TRUE :
  VAL no.of.columns   IS 6 :
  VAL width.of.column IS 10 :
  TIMER timer:                    -- DCW
  INT start.time, end.time:       -- DCW
  INT column.count :
  --{{{  [INLINE] PROC out (VAL INT ch)
  PROC out (VAL INT ch)
    SEQ
      IF
        (ch >= 0) AND (ch < 256)
          scr ! BYTE ch
        TRUE
          SKIP
  :
  --}}}
  --{{{  PROC newline ()
  PROC newline ()
    SEQ
      out.nl (scr)
      column.count := 0
  :
  --}}}
  --{{{  PROC writes (VAL []BYTE s)
  PROC writes (VAL []BYTE s)
    out.string (s, 0, scr)
  :
  --}}}
  --{{{  [INLINE] PROC in (INT ch)
  PROC in (INT ch)
    --all input goes via this proc, but its only ever used to wait
    SEQ
      --newline ()
      --writes ("(Press any key) ")
      -- keyboard ? ch
      ch := ch  -- stop any warning not used
      newline ()
  :
  --}}}
  --{{{  [INLINE] PROC writen (VAL INT n)
  PROC writen (VAL INT n)
    out.number (n, 0, scr)
  :
  --}}}
  --{{{  [INLINE] PROC writehex (VAL INT value, length)
  PROC writehex (VAL INT value, length)
    --VAL hex IS "0123456789ABCDEF" :
    --SEQ
    --  SEQ i = 1 FOR length
    --    out (INT hex [(value >> ((length - i) * 4)) /\ #F] )
    --  out (-2)
    out.hex.int (value, length, scr)
  :
  --}}}
  --{{{  [INLINE] PROC beep ()
  PROC beep ()
    out (7)
  :
  --}}}
  --{{{  PROC failed.test  (VAL []BYTE where)
  PROC failed.test(VAL []BYTE where)
    SEQ
      beep()
      writes(where)
      IF
        display.names
          newline()
        TRUE
          SKIP
      writes (" Failed: ")
  :
  --}}}
  --{{{  PROC completed.ok (VAL []BYTE where)
  INT error.count, passed.count:
  PROC completed.ok (VAL []BYTE where)
    SEQ
      passed.count := passed.count + 1
      IF
        display.names
          SEQ
            writes (where)
            IF
              column.count < no.of.columns
                VAL spaces IS "            " :
                VAL INT n.spaces IS width.of.column - (SIZE where):
                SEQ
                  IF
                    n.spaces > 0
                      writes([spaces FROM 0 FOR width.of.column - (SIZE where)])
                      --SEQ i = 0 FOR width.of.column - (SIZE where)
                      --  out ('*s' (INT))
                    TRUE
                      out ('*s' (INT))
                  column.count := column.count + 1
              TRUE
                newline ()
        TRUE
          SKIP
  :
  --}}}
  INT any.integer.name :
  VAL []BYTE useless.name RETYPES any.integer.name :
  VAL nibbles.per.INT IS (SIZE useless.name) * 2 :
  --{{{  PROC check.BOOL (VAL BOOL val1, val2, VAL []BYTE test.type)
  PROC check.BOOL (VAL BOOL val1, val2, VAL []BYTE test.type)
    INT key :
    PROC writebool (VAL BOOL b)
      IF
        b
          writes ("TRUE")
        TRUE
          writes ("FALSE")
    :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writebool (val1)
            writes ("  ")
            writebool (val2)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check.BYTE (VAL BYTE val1, val2, VAL []BYTE test.type)
  PROC check.BYTE (VAL BYTE val1, val2, VAL []BYTE test.type)
    INT key :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writehex (INT val1, 2)
            writes ("  ")
            writehex (INT val2, 2)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check.INT (VAL INT val1, val2, VAL []BYTE test.type)
  PROC check.INT (VAL INT val1, val2, VAL []BYTE test.type)
    INT key :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writehex (val1, nibbles.per.INT)
            writes ("  ")
            writehex (val2, nibbles.per.INT)
            writes ("  ")
            writen (val1)
            writes ("  ")
            writen (val2)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check (VAL INT val1, val2, VAL []BYTE test.type)
  --INLINE PROC check (VAL INT val1, val2, VAL []BYTE test.type)
  -- If this is inline, every invocation creates an abbreviation
  -- VAL test.type IS "..." :
  -- and this makes the map file huge!
  PROC check (VAL INT val1, val2, VAL []BYTE test.type)
    check.INT (val1, val2, test.type)
    --{{{  COMMENT
    --IF
      --val1 = val2
        --check.INT (val1, val2, test.type)
      --TRUE
        --out.string ("!!! FAILED in check !!!*n*c", 0, out)
    --}}}
  :
  --}}}
  --{{{  PROC init (VAL []BYTE name, description)
  [20]BYTE saved.name :
  INT saved.name.len :
  PROC init (VAL []BYTE name, description)
    SEQ
      timer ? start.time          -- DCW
      writes (name)
      writes ("  --  ")
      writes (description)
      newline ()
      error.count := 0
      passed.count := 0
      saved.name.len := SIZE name
      [saved.name FROM 0 FOR saved.name.len] := name
  :
  --}}}
  --{{{  PROC title (VAL []BYTE string)
  PROC title (VAL []BYTE string)
    IF
      display.titles
        SEQ
          IF
            display.names
              newline ()
            TRUE
              SKIP
            TRUE
              STOP
          writes(string)
          newline()
      TRUE
        SKIP
      TRUE
        STOP
  :
  --}}}
  --{{{  PROC finish ()
  PROC finish ()
    SEQ
      IF
        display.names
          newline ()
        TRUE
          SKIP
      IF
        error.count > 0
          SEQ
            writes ("^^^ Failed : ")
            writes ([saved.name FROM 0 FOR saved.name.len])
            writes (": ")
            writen (error.count)
            writes (" errors detected, ")
        TRUE
          SEQ
            writes ("^^^ Passed : ")
            writes ([saved.name FROM 0 FOR saved.name.len])
            writes (": All ")
      writen (passed.count)
      writes (" tests passed OK")
      timer ? end.time            -- DCW
      newline ()
      writes ("Time = ")
      writen (end.time - start.time)
      writes (" ticks")
      newline ()
  :
  --}}}
  --{{{  identity functions
  -- These are designed to help stop the optimiser constant propagating.
  -- If it manages to defeat these, make them more complex, as long as they
  -- still return the identity function.
  BOOL   FUNCTION id.BOOL   (VAL BOOL   x)
    BOOL res :
    VALOF
      res := x
      RESULT res
  :
  BYTE   FUNCTION id.BYTE   (VAL BYTE   x)
    BYTE   res :
    VALOF
      res := x
      RESULT res
  :
  INT    FUNCTION id.INT    (VAL INT    x)
    INT    res :
    VALOF
      res := x
      RESULT res
  :
  INT16  FUNCTION id.INT16  (VAL INT16  x)
    INT16  res :
    VALOF
      res := x
      RESULT res
  :
  INT32  FUNCTION id.INT32  (VAL INT32  x)
    INT32  res :
    VALOF
      res := x
      RESULT res
  :
  INT64  FUNCTION id.INT64  (VAL INT64  x)
    INT64  res :
    VALOF
      res := x
      RESULT res
  :
  REAL32 FUNCTION id.REAL32 (VAL REAL32 x)
    REAL32 res :
    VALOF
      res := x
      RESULT res
  :
  REAL64 FUNCTION id.REAL64 (VAL REAL64 x)
    REAL64 res :
    VALOF
      res := x
      RESULT res
  :
  INT    FUNCTION id        (VAL INT    x)
    INT    res :
    VALOF
      res := x
      RESULT res
  :
  --}}}
  --}}}
  --{{{  cgreal.occ
  -- version control marker $Id: cgreal.occ,v 1.1 1995/10/10 13:03:56 djb1 Exp $
  --{{{  PROC check.INT16 (VAL INT16 val1, val2, VAL []BYTE test.type)
  PROC check.INT16 (VAL INT16 val1, val2, VAL []BYTE test.type)
    INT key :
    SEQ
      IF
        val1 = val2
          completed.ok (test.type)
        TRUE
          SEQ
            failed.test(test.type)
            writehex (INT val1, 4)
            writes ("  ")
            writehex (INT val2, 4)
            in (key)
            error.count := error.count + 1
  :
  --}}}
  --{{{  PROC print.failed.values(VAL []BYTE test.type, VAL []INT x1, x2)
  PROC print.failed.values(VAL []BYTE test.type, VAL []INT x1, x2)
    PROC print.value(VAL []INT x)
      SEQ i = 0 FOR SIZE x
        writehex (x [((SIZE x) - 1) - i], nibbles.per.INT)
    :
    INT key :
    SEQ
      failed.test(test.type)
      print.value(x1)
      writes("  ")
      print.value(x2)
      in (key)
      error.count := error.count + 1
  :
  --}}}
  --{{{  PROC check.INT32 (VAL INT32 val1, val2, VAL []BYTE test.type)
  PROC check.INT32 (VAL INT32 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  PROC check.INT64 (VAL INT64 val1, val2, VAL []BYTE test.type)
  PROC check.INT64 (VAL INT64 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  old out.REAL32 and out.REAL64
  --PROC outREAL32 (VAL REAL32 Real)
  --  SKIP
  --:
  --PROC outREAL64 (VAL REAL64 real)
  --  SKIP
  --:
  --}}}
  --{{{  PROC check.REAL32 (VAL REAL32 val1, val2, VAL []BYTE test.type)
  PROC check.REAL32 (VAL REAL32 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  PROC check.REAL64 (VAL REAL64 val1, val2, VAL []BYTE test.type)
  PROC check.REAL64 (VAL REAL64 val1, val2, VAL []BYTE test.type)
    IF
      val1 = val2
        completed.ok (test.type)
      TRUE
        VAL []INT i.val1 RETYPES val1 :
        VAL []INT i.val2 RETYPES val2 :
        print.failed.values(test.type, i.val1, i.val2)
  :
  --}}}
  --{{{  PROC check.string (VAL []BYTE val1, val2, VAL []BYTE test.type)
  PROC check.string (VAL []BYTE val1, val2, VAL []BYTE test.type)
    INT key:
    IF
      (SIZE val1) <> (SIZE val2)
        SEQ
          failed.test (test.type)
          writes (" string size mismatch")
          in (key)
          error.count := error.count + 1
      IF i = 0 FOR SIZE val1
        val1[i] <> val2[i]
          SEQ
            failed.test (test.type)
            writes (" strings not equal")
            in (key)
            error.count := error.count + 1
      TRUE
        completed.ok (test.type)
  :
  --}}}
  --}}}
  INT key :
  BOOL x :
  SEQ
    init ("CG test 11", "Basic arithmetic types")
    --#INCLUDE "cg10misc.occ"
    --#INCLUDE "cg10r64.occ"
    --#INCLUDE "cg10r32.occ"
    --#INCLUDE "cg10i64.occ"
    --#INCLUDE "cg10i32.occ"
    --#INCLUDE "cg10i16.occ"
    --{{{  cg10int.occ
    -- version control marker $Id: cg10int.occ,v 1.1 1995/10/10 13:03:09 djb1 Exp $
    PROC do.INT ()
      INT a, b , c:
      SEQ
        b := id.INT(85 (INT))
        --{{{  output message
        title ("INT arithmetic")
        --}}}
        --{{{  check arithmetic and logical operators  (INT-000 to 099)
        a := b + 23 (INT)
        check.INT (a, 85(INT) + 23(INT), "INT-001")
        a := b PLUS 23 (INT)
        check.INT (a, 85(INT) PLUS 23(INT), "INT-002")
        a := b - 23 (INT)
        check.INT (a, 85(INT) - 23(INT), "INT-003")
        a := b MINUS 23 (INT)
        check.INT (a, 85(INT) MINUS 23(INT), "INT-004")
        a := b * 23 (INT)
        check.INT (a, 85(INT) * 23(INT), "INT-005")
        a := b TIMES 23 (INT)
        check.INT (a, 85(INT) TIMES 23(INT), "INT-006")
        a := b / 23 (INT)
        check.INT (a, 85(INT) / 23(INT), "INT-007")
        a := b \ 23 (INT)
        check.INT (a, 85(INT) \ 23(INT), "INT-008")
        --{{{  check logical operators                 (INT-009 to 014)
        a := b << 3
        check.INT (a, 85(INT) << 3, "INT-009")
        a := b >> 3
        check.INT (a, 85(INT) >> 3, "INT-010")
        a := b /\ 23 (INT)
        check.INT (a, 85(INT) /\ 23(INT), "INT-011")
        a := b \/ 23 (INT)
        check.INT (a, 85(INT) \/ 23(INT), "INT-012")
        a := b >< 23 (INT)
        check.INT (a, 85(INT) >< 23(INT), "INT-013")
        a := ~b
        check.INT (a, ~85(INT), "INT-014")
        --}}}
        --{{{  unary minus                             (INT-015 to 018)
        a := (- b)
        check.INT (a, -85(INT), "INT-015")
        a := (MINUS b)
        check.INT (a, MINUS 85(INT), "INT-016")
        --{{{
        a := MINUS (MOSTNEG INT)
        check.INT (a, MOSTNEG INT, "INT-017")
        --}}}
        --{{{
        c := MOSTNEG INT
        a := MINUS c
        check.INT (a, c, "INT-018")
        --}}}
        --}}}
        --{{{  sign extension                          (INT-019 to 029)
        PROC extension()
          PROC local(VAL INT w, x, y, z, INT i)
            i := ((INT w) + (INT x)) + ((INT y) + (INT z))
          :
          INT i :
          SEQ
            local(-1(INT), -1(INT), -1(INT), -1(INT), i)
            check(i, -4, "INT-019")
            local(1(INT), 1(INT), 1(INT), 1(INT), i)
            check(i, 4, "INT-020")
        :
        extension()
        --}}}
        --{{{  overflow checks on logical operators    (INT-030 to 039)
        INT p, q, r :
        SEQ
          p := id.INT(MOSTPOS INT)
          q := p PLUS 256(INT)
          check.INT(q, (MOSTNEG INT) + 255(INT), "INT-030")
          p := id.INT(MOSTNEG INT)
          q := p PLUS (-256(INT))
          check.INT(q, (MOSTPOS INT) - 255(INT), "INT-031")
          p := id.INT(MOSTPOS INT)
          q := p MINUS (-256(INT))
          check.INT(q, (MOSTNEG INT) + 255(INT), "INT-032")
          p := id.INT(MOSTNEG INT)
          q := p MINUS 256(INT)
          check.INT(q, (MOSTPOS INT) - 255(INT), "INT-033")
          p := id.INT(MOSTPOS INT)
          q := p TIMES 2(INT)
          check.INT(q, (MOSTPOS INT) TIMES 2(INT), "INT-034")
          check.INT(q, (MOSTPOS INT) << 1,           "INT-035")
          p := id.INT(MOSTPOS INT)
          q := MINUS p
          check.INT(q, 0(INT) MINUS (MOSTPOS INT), "INT-036")
          check.INT(q, (MOSTNEG INT) + 1(INT),     "INT-037")
          r := id.INT(0(INT))
          p := id.INT(MOSTPOS INT)
          q := (p PLUS 256(INT)) + r
          check.INT(q, (MOSTNEG INT) + 255(INT), "INT-038")
        --}}}
        --}}}
        --{{{  check constant folding                  (INT-100 to 199)
        INT a, b :
        INT c :
        SEQ
          b := id.INT(5 (INT))
          c := 3
          --{{{  +        (INT-100)
          a := 2 (INT) + b               -- 7
          a := (1 (INT) + b    ) + a     -- 6
          a := (0 (INT) + b    ) + a     -- 5
          a := ((-1 (INT)) + b ) + a     -- 4
          a := ((-2 (INT)) + b ) + a     -- 3
          a := (b + 2 (INT)    ) + a     -- 7
          a := (b + 1 (INT)    ) + a     -- 6
          a := (b + 0 (INT)    ) + a     -- 5
          a := (b + (-1 (INT)) ) + a     -- 4
          a := (b + (-2 (INT)) ) + a     -- 3
          check.INT (a, 50 (INT), "INT-100")
          --}}}
          --{{{  -        (INT-101)
          a := 2 (INT) - b               --  -3
          a := (1 (INT) - b    ) + a     --  -4
          a := (0 (INT) - b    ) + a     --  -5
          a := ((-1 (INT)) - b ) + a     --  -6
          a := ((-2 (INT)) - b ) + a     --  -7
          a := (b - 2 (INT)    ) + a     --   3
          a := (b - 1 (INT)    ) + a     --   4
          a := (b - 0 (INT)    ) + a     --   5
          a := (b - (-1 (INT)) ) + a     --   6
          a := (b - (-2 (INT)) ) + a     --   7
          check.INT (a, 0 (INT), "INT-101")
          --}}}
          --{{{  *        (INT-102)
          a := 2 (INT) * b                 --  10
          a := (1 (INT) * b      ) + a     --   5
          a := (0 (INT) * b      ) + a     --   0
          a := ((-1 (INT)) * b   ) + a     --  -5
          a := ((-2 (INT)) * b   ) + a     -- -10
          a := (b * 2 (INT)      ) + a     --  10
          a := (b * 1 (INT)      ) + a     --   5
          a := (b * 0 (INT)      ) + a     --   0
          a := (b * (-1 (INT))   ) + a     --  -5
          a := (b * (-2 (INT))   ) + a     -- -10
          check.INT (a, 0 (INT), "INT-102")
          --}}}
          --{{{  /        (INT-103)
          a := 2 (INT) / b                 -- 0
          a := (1 (INT) / b      ) + a     -- 0
          a := (0 (INT) / b      ) + a     -- 0
          a := ((-1 (INT)) / b   ) + a     -- 0
          a := ((-2 (INT)) / b   ) + a     -- 0
          a := (b / 2 (INT)      ) + a     -- 2
          a := (b / 1 (INT)      ) + a     -- 5
          --a := b / 0 (INT)  --should give error
          a := (b / (-1 (INT))   ) + a     -- -5
          a := (b / (-2 (INT))   ) + a     -- -2
          check.INT (a, 0 (INT), "INT-103")
          --}}}
          --{{{  \        (INT-104)
          a := 2 (INT) \ b                 --  2
          a := (1 (INT) \ b      ) + a     --  1
          a := (0 (INT) \ b      ) + a     --  0
          a := ((-1 (INT)) \ b   ) + a     -- -1
          a := ((-2 (INT)) \ b   ) + a     -- -2
          a := (b \ 2 (INT)      ) + a     --  1
          a := (b \ 1 (INT)      ) + a     --  0
          --a := b \ 0 (INT)  --should give error
          a := (b \ (-1 (INT))   ) + a     --  0
          a := (b \ (-2 (INT))   ) + a     --  1
          check.INT (a, 2 (INT), "INT-104")
          --}}}
          --{{{  PLUS     (INT-105)
          a := 2 (INT) PLUS b                 -- 7
          a := (1 (INT) PLUS b      ) + a     -- 6
          a := (0 (INT) PLUS b      ) + a     -- 5
          a := ((-1 (INT)) PLUS b   ) + a     -- 4
          a := ((-2 (INT)) PLUS b   ) + a     -- 3
          a := (b PLUS 2 (INT)      ) + a     -- 7
          a := (b PLUS 1 (INT)      ) + a     -- 6
          a := (b PLUS 0 (INT)      ) + a     -- 5
          a := (b PLUS (-1 (INT))   ) + a     -- 4
          a := (b PLUS (-2 (INT))   ) + a     -- 3
          check.INT (a, 50 (INT), "INT-105")
          --}}}
          --{{{  MINUS    (INT-106)
          a := 2 (INT) MINUS b                  --  -3
          a := (1 (INT) MINUS b       ) + a     --  -4
          a := (0 (INT) MINUS b       ) + a     --  -5
          a := ((-1 (INT)) MINUS b    ) + a     --  -6
          a := ((-2 (INT)) MINUS b    ) + a     --  -7
          a := (b MINUS 2 (INT)       ) + a     --   3
          a := (b MINUS 1 (INT)       ) + a     --   4
          a := (b MINUS 0 (INT)       ) + a     --   5
          a := (b MINUS (-1 (INT))    ) + a     --   6
          a := (b MINUS (-2 (INT))    ) + a     --   7
          check.INT (a, 0 (INT), "INT-106")
          --}}}
          --{{{  TIMES    (INT-107)
          a := 2 (INT) TIMES b                --  10
          a := (1 (INT) TIMES b     ) + a     --   5
          a := (0 (INT) TIMES b     ) + a     --   0
          a := ((-1 (INT)) TIMES b  ) + a     --  -5
          a := ((-2 (INT)) TIMES b  ) + a     -- -10
          a := (b TIMES 2 (INT)     ) + a     --  10
          a := (b TIMES 1 (INT)     ) + a     --   5
          a := (b TIMES 0 (INT)     ) + a     --   0
          a := (b TIMES (-1 (INT))  ) + a     --  -5
          a := (b TIMES (-2 (INT))  ) + a     -- -10
          check.INT (a, 0 (INT), "INT-107")
          --}}}
          --{{{  /\       (INT-108)
          a := 2 (INT) /\ b                   -- 0
          a := (1 (INT) /\ b        ) + a     -- 1
          a := (0 (INT) /\ b        ) + a     -- 0
          a := ((-1 (INT)) /\ b     ) + a     -- 5
          a := ((-2 (INT)) /\ b     ) + a     -- 4
          a := (b /\ 2 (INT)        ) + a     -- 0
          a := (b /\ 1 (INT)        ) + a     -- 1
          a := (b /\ 0 (INT)        ) + a     -- 0
          a := (b /\ (-1 (INT))     ) + a     -- 5
          a := (b /\ (-2 (INT))     ) + a     -- 4
          check.INT (a, 20 (INT), "INT-108")
          a := b /\ 0(INT)
          check.INT (a, 0(INT), "INT-108a")
          a := b /\ (-1(INT))
          check.INT (a, 5(INT), "INT-108b")
          a := b /\ b
          check.INT (a, 5(INT), "INT-108c")
          --}}}
          --{{{  \/       (INT-109)
          a := 2 (INT) \/ b                 --  7
          a := (1 (INT) \/ b      ) + a     --  5
          a := (0 (INT) \/ b      ) + a     --  5
          a := ((-1 (INT)) \/ b   ) + a     -- -1
          a := ((-2 (INT)) \/ b   ) + a     -- -1
          a := (b \/ 2 (INT)      ) + a     --  7
          a := (b \/ 1 (INT)      ) + a     --  5
          a := (b \/ 0 (INT)      ) + a     --  5
          a := (b \/ (-1 (INT))   ) + a     -- -1
          a := (b \/ (-2 (INT))   ) + a     -- -1
          check.INT (a, 30 (INT), "INT-109")
          a := b \/ 0(INT)
          check.INT (a, 5(INT), "INT-109a")
          a := b \/ (-1(INT))
          check.INT (a, -1(INT), "INT-109b")
          a := b \/ b
          check.INT (a, 5(INT), "INT-109c")
          --}}}
          --{{{  ><       (INT-110)
          a := 2 (INT) >< b                  --  7
          a := (1 (INT) >< b       ) + a     --  4
          a := (0 (INT) >< b       ) + a     --  5
          a := ((-1 (INT)) >< b    ) + a     -- -6
          a := ((-2 (INT)) >< b    ) + a     -- -5
          a := (b >< 2 (INT)       ) + a     --  7
          a := (b >< 1 (INT)       ) + a     --  4
          a := (b >< 0 (INT)       ) + a     --  5
          a := (b >< (-1 (INT))    ) + a     -- -6
          a := (b >< (-2 (INT))    ) + a     -- -5
          check.INT (a, 10 (INT), "INT-110")
          a := b >< 0(INT)
          check.INT (a, 5(INT), "INT-110a")
          a := b >< (-1(INT))
          check.INT (a, -6(INT), "INT-110b")
          a := b >< b
          check.INT (a, 0(INT), "INT-110c")
          --}}}
          --{{{  <<       (INT-111)
          a := 64 (INT) << c                 --  512
          a := (32 (INT) << c      ) + a     --  256
          a := (0 (INT) << c       ) + a     --    0
          a := ((-64 (INT)) << c   ) + a     -- -256
          a := ((-32 (INT)) << c   ) + a     -- -512
          --a := (b << 64              ) + a     --    0
          --a := (b << 32              ) + a     --    0         won't work on T2
          --a := (b << 16              ) + a     --   (5 << 16)  different when its a T2
          a := (b << 8               ) + a     --   (5 << 8)
          a := (b << 0               ) + a     --    5
          --a := b << (-64) --should give error
          --a := b << (-32) --should give error
          VAL correct.result IS 5(INT) + (5(INT) <<  8) :
          check.INT (a, correct.result, "INT-111")
          --}}}
          --{{{  >>       (INT-112)
          a := 64 (INT) >> c                --  8
          a := (32 (INT) >> c     ) + a     --  4
          a := (0 (INT) >> c      ) + a     --  0
          a := ((-64 (INT)) >> c  ) + a     --  (-64 >> 3)
          a := ((-32 (INT)) >> c  ) + a     --  (-32 >> 3)
          --a := (b >> 64             ) + a     --  0
          --a := (b >> 32             ) + a     --  0    (won't work on T2)
          a := (b >> 16             ) + a     --  0
          a := (b >> 8              ) + a     --  0
          a := (b >> 0              ) + a     --  5
          --a := b >> (-64) --should give error
          --a := b >> (-32) --should give error
          VAL correct.result IS 17 (INT) +
                     ( ( (-64(INT)) >> 3) + ( (-32(INT)) >> 3) ) :
          check.INT (a, correct.result, "INT-112")
          --}}}
        --}}}
        --{{{  check comparison operators              (INT-200 to 299)
        a := id.INT(47(INT))
        x := a = b
        check.BOOL (x, FALSE, "INT-205")
        x := a > b
        check.BOOL (x, FALSE, "INT-206")
        x := a >= b
        check.BOOL (x, FALSE, "INT-207")
        x := a < b
        check.BOOL (x, TRUE, "INT-208")
        x := a <= b
        check.BOOL (x, TRUE, "INT-209")
        x := a <> b
        check.BOOL (x, TRUE, "INT-210")
        x := a AFTER b
        check.BOOL (x, FALSE, "INT-211")
        --}}}
        --{{{  check conversions                       (INT-300 to 399)
        --{{{  variables for conversion tests
        REAL64 r64 :
        REAL32 r32 :
        INT64 i64 :
        INT32 i32 :
        INT16 i16 :
        BYTE byte :
        BOOL bool :
        --}}}
        SEQ
          r64 := REAL64 TRUNC b
          check.REAL64 (r64, REAL64 TRUNC 85(INT), "INT-301")
          r64 := REAL64 ROUND b
          check.REAL64 (r64, REAL64 ROUND 85(INT), "INT-302")
          r32 := REAL32 TRUNC b
          check.REAL32 (r32, REAL32 TRUNC 85(INT), "INT-303")
          r32 := REAL32 ROUND b
          check.REAL32 (r32, REAL32 ROUND 85(INT), "INT-304")
          i64 := INT64 b
          check.INT64 (i64, INT64 85(INT), "INT-305")
          i32 := INT32 b
          check.INT32 (i32, INT32 85(INT), "INT-306")
          i16 := INT16 b
          check.INT16 (i16, INT16 85(INT), "INT-307")
          byte := BYTE b
          check.BYTE (byte, BYTE 85(INT), "INT-308")
          c := 1(INT)
          bool := BOOL c
          check.BOOL (bool, BOOL 1(INT), "INT-309")
        --}}}
        --{{{  check 'remainder identity'              (INT-400 to 499)
        a := ( 23(INT) * ( b / 23(INT) ) ) + ( b \ 23(INT) )
        check.INT (a,
          ( 23(INT) * ( 85(INT) / 23(INT) ) ) + ( 85(INT) \ 23(INT) ),
          "INT-400")
        check.INT (a, b, "INT-401")
        --}}}
        --{{{  hefty calculations                      (INT-500 to 599)
        --{{{  declarations
        INT x, y, z, a, b, c, d :
        VAL n1 IS 1(INT) :
        VAL n2 IS 2(INT) :
        VAL n3 IS 3(INT) :
        VAL n4 IS 1(INT) / 3(INT) :
        VAL twice.eight.four IS 8192(INT) : -- twice 8 to the power 4 (= 2 to the 13)
        --}}}
        SEQ
          --{{{  initialisation
          x := 8(INT)
          y := x + x
          z := y - x
          a := 11111(INT)
          b := 22222(INT)
          c := a * 2(INT)
          --}}}
          check.INT (y, 16(INT), "INT-500")
          check.INT (z,  8(INT), "INT-501")
          check.INT (c,  b, "INT-502")
          check.INT (((x + y) + (n3 * z)) + ((n2 * a) - b), 48(INT), "INT-503")
          check.INT (((x PLUS y) PLUS (n3 TIMES z)) PLUS ((n2 TIMES a) MINUS b), 48(INT), "INT-503a")
          check.INT (x + (x + (x + (x + (x + (x + x))))), 56(INT), "INT-504")
          check.INT (x PLUS (x PLUS (x PLUS (x PLUS (x PLUS (x PLUS x))))), 56(INT), "INT-504a")
          check.INT ((x * (x * (x * x))) + (x * (x * (x * x))),
                       twice.eight.four, "INT-505")
          check.INT ((x TIMES (x TIMES (x TIMES x))) PLUS (x TIMES (x TIMES (x TIMES x))),
                       twice.eight.four, "INT-505a")
          check.INT ((n2 * (y * (y * x))) + (n2 * (y * (y * x))),
                       twice.eight.four, "INT-506")
          check.INT ((n2 TIMES (y TIMES (y TIMES x))) PLUS (n2 TIMES (y TIMES (y TIMES x))),
                       twice.eight.four, "INT-506a")
          x := 1 (INT)
          y := 3 (INT)
          d := 2 (INT)
          check.INT (x / y, n4, "INT-507")
          c := ((d * y) * (d * y)) * ((d * y) * (d * y))
          check.INT (c, 1296 (INT), "INT-509")
          c := ((d TIMES y) TIMES (d TIMES y)) TIMES ((d TIMES y) TIMES (d TIMES y))
          check.INT (c, 1296 (INT), "INT-509a")
          c := ((((d * y) * (d * y)) * (d * y)) * (d * y)) * (d * y)
          check.INT (c, 7776 (INT), "INT-510")
          c := ((((d TIMES y) TIMES (d TIMES y)) TIMES (d TIMES y)) TIMES (d TIMES y)) TIMES (d TIMES y)
          check.INT (c, 7776 (INT), "INT-510a")
        --}}}
        --{{{  passing as parameters                   (INT-600 to 699)
        --{{{  copy.int and add.int
        PROC copy.int (VAL INT x, INT y)
          y := x
        :
        PROC add.int (VAL INT x, y, INT z)
          z := x + y
        :
        --}}}
        INT x, y, z :
        VAL n1 IS 2(INT) :
        VAL n2 IS 5000(INT) :
        SEQ
          copy.int (n1, x)
          check.INT (x, 2(INT), "INT-600")
          copy.int (n2, x)
          check.INT (x, 5000(INT), "INT-601")
          y := 57 (INT)
          copy.int (y, x)
          check.INT (x, 57(INT), "INT-602")
          add.int (n1, n2, x)
          check.INT (x, 5002(INT), "INT-603")
          y := n1
          z := n2
          add.int (y, z, x)
          check.INT (x, 5002(INT), "INT-604")
          check.INT (z, 5000(INT), "INT-605")
        --}}}
        --{{{  arrays                                  (INT-700 to 799)
        VAL n IS 1(INT) :
        VAL m IS 2(INT) :
        VAL t1 IS [n, n, n, n, m] :
        VAL t2 IS [t1, t1, t1, t1 ] :
        VAL t3 IS [t2, t2, t2 ] :
        BOOL b :
        INT x :
        INT tot :
        SEQ
          check.INT (t1 [0], n,         "INT-700")
          check.INT (t1 [4], m,         "INT-701")
          check.INT (t2 [2] [4], m,     "INT-702")
          check.INT (t3 [1] [2] [4], m, "INT-703")
          --{{{  test individual access
          b := TRUE
          x := 4
          tot := 0(INT)
          SEQ i = 0 FOR SIZE t3
            SEQ j = 0 FOR SIZE t2
              SEQ k = 0 FOR SIZE t1
                SEQ
                  IF
                    (k = 4) AND (t3 [i] [j] [k] = m)
                      SKIP
                    (k < 4) AND (t3 [i] [j] [k] = n)
                      SKIP
                    TRUE
                      b := FALSE
                  tot := tot + t3 [i] [j] [k]
                  x := INT t3 [i] [j] [x]      -- sets it to 1
                  x := 4                       -- resets it again
          check.BOOL (b, TRUE, "INT-704")
          VAL correct.value IS (48(INT) * n) + (12(INT) * m) :
          check.INT (tot, correct.value, "INT-705")
          --}}}
          --{{{  test nested array access
          INT a, b, c :
          SEQ
            a := 2
            b := 1
            c := 3
            tot := t3[a][b][c] + ( t3[b][a][c] + ( t3[0][1][4] + ( t3[b][a+b][b+(a+b)] +
                   t1[(a+b)+b] ) ) )
            VAL correct.value IS (2(INT) * n) + (3(INT) * m) :
            check.INT (tot, correct.value, "INT-706")
            tot := t3 [a] [ INT t3 [a] [b] [INT t3 [b + b] [a +
                            b] [b + (a + b)] ] ] [(INT t3 [a] [c] [c +
                            (b - a)]) + (3 * (INT t3 [a] [c] [b])) ]
            check.INT (tot, m, "INT-707")
          --}}}
          --{{{  test individual access using abbreviations
          b := TRUE
          x := 4
          tot := 0(INT)
          SEQ i = 0 FOR SIZE t3
            VAL a2 IS t3 [i] :
            SEQ j = 0 FOR SIZE t2
              VAL a1 IS a2 [j] :
              SEQ k = 0 FOR SIZE t1
                VAL a0 IS a1 [k] :
                SEQ
                  IF
                    (k = 4) AND (a0 = m)
                      SKIP
                    (k < 4) AND (a0 = n)
                      SKIP
                    TRUE
                      b := FALSE
                  tot := tot + a0
                  x := INT a1 [x]              -- sets it to 1
                  x := 4                       -- resets it again
          check.BOOL (b, TRUE, "INT-708")
          VAL correct.value IS (48(INT) * n) + (12(INT) * m) :
          check.INT (tot, correct.value, "INT-709")
          --}}}
          --{{{  test livermore loop                   (INT-710 to 711)
          PROC livermore()
            VAL n IS 10 :
            VAL r IS 7(INT) :
            VAL t IS 13(INT) :
            [n + 6] INT u :
            [n] INT x, y, z :
            SEQ
              SEQ k = 0 FOR n + 6
                u [k] := 3(INT)
              SEQ k = 0 FOR n
                SEQ
                  y [k] := 11(INT)
                  z [k] :=  5(INT)
              SEQ k = 0 FOR n
                x [k] := u[k] + ((( r * (z[k] + (r * y[k]))) +
                                  (t * ((u[k+3] + (r * (u[k+2] + (r * u[k+1]))))))) +
                                  (t * ((u[k+6] + (r * (u[k+5] + (r * u[k+4])))))))
              check.INT (x[0],     5023(INT), "INT-710")
              check.INT (x[n - 1], 5023(INT), "INT-711")
          :
          livermore()
          --}}}
          --{{{  test some bugs that were found        (INT-712 to 716)
          PROC bug.tests()
            SEQ
              --{{{  bug1                                  (INT-712)
              [2][2]INT arr :
              INT A :
              INT i :
              SEQ
                i := 0
                arr[i][i] := 0(INT)
                A := ((arr[i][i]+arr[i][i]) + (arr[i][i]+arr[i][i])) / 4(INT)
                check.INT (A, 0(INT), "INT-712")
              --}}}
              --{{{  bug3                                  (INT-713 to 714)
              PROC Complex.Subst ([]INT a, b)
                SEQ
                  check.INT (a[0], 2(INT), "INT-713")
                  check.INT (b[1], 4(INT), "INT-714")
              :
              [2][2][2]INT g.plus, g.minus :
              INT i, j :
              SEQ
                i := 1(INT)
                j := 0(INT)
                g.plus [INT i][INT j][0] := 2(INT)
                g.minus[INT i][INT j][1] := 4(INT)
                Complex.Subst (g.plus[INT i][INT j],
                               g.minus[INT i][INT j])
              --}}}
              --{{{  bug4                                  (INT-715)
              [10][10]INT c, b :
              INT i :
              INT A:
              SEQ
                i := 1
                SEQ i = 0 FOR 10
                  SEQ j = 0 FOR 10
                    VAL tmp IS INT j :
                    c [i][j] := tmp
                A := ((c[i][i] * c [i*i][i+2])) / (c[(i*i)+i][(i*i)+i] + c[i][i])
                check.INT (A, 1(INT), "INT-715")
              --}}}
              --{{{  test2                                 (INT-716)
              INT u :
              [4] INT ai :
              [3] [4] INT x, Gb :
              INT i, j, k :
              SEQ
                SEQ i = 0 FOR 4
                  SEQ
                    ai [i] := 5(INT)
                    SEQ j = 0 FOR 3
                      SEQ
                        x [j] [i] := 2(INT)
                        Gb[j] [i] := 24(INT)
                u := 4(INT)
                i := 1
                j := 2
                k := 3
                u := u + (ai [j] * x [j][k])
                x [i][k] := (Gb [i][k] - u) / ai[i]
                check.INT (x [i][k], 2(INT), "INT-716")
                u := 4(INT)
                u := u PLUS (ai [j] TIMES x [j][k])
                x [i][k] := (Gb [i][k] MINUS u) / ai[i]
                check.INT (x [i][k], 2(INT), "INT-717")
              --}}}
          :
          bug.tests()
          --}}}
        --}}}
        --{{{  miscellaneous bug checks                (INT-800 to 899)
        --}}}
        --{{{  more conversion tests
        INT FUNCTION id(VAL INT i) IS i :
        VAL n IS 5 :
        VAL m IS 7 :
        [n][m]INT64 i64arr :
        [n][m]INT32 i32arr :
        [n][m]INT16 i16arr :
        [n][m]INT   iarr :
        [n][m]REAL32 r32arr :
        [n][m]REAL64 r64arr :
        INT i, j :
        VAL ans IS (n / 2) + (m / 2) :
        SEQ
          i, j := n / 2, m / 2
          SEQ k = 0 FOR n
            SEQ l = 0 FOR m
              iarr[k][l] := INT(k + l)
          r64arr[i][j] := REAL64 ROUND iarr[i][j]
          check.REAL64(r64arr[i][j], REAL64 ROUND ans, "INT-R64-1")
          r64arr[id(i)][j] := REAL64 ROUND iarr[id(i)][j]
          check.REAL64(r64arr[i][j], REAL64 ROUND ans, "INT-R64-2")
          r64arr[i][j] := REAL64 TRUNC iarr[i][j]
          check.REAL64(r64arr[i][j], REAL64 TRUNC ans, "INT-R64-3")
          r64arr[id(i)][j] := REAL64 TRUNC iarr[id(i)][j]
          check.REAL64(r64arr[i][j], REAL64 TRUNC ans, "INT-R64-4")
          r32arr[i][j] := REAL32 ROUND iarr[i][j]
          check.REAL32(r32arr[i][j], REAL32 ROUND ans, "INT-R32-1")
          r32arr[id(i)][j] := REAL32 ROUND iarr[id(i)][j]
          check.REAL32(r32arr[i][j], REAL32 ROUND ans, "INT-R32-2")
          r32arr[i][j] := REAL32 TRUNC iarr[i][j]
          check.REAL32(r32arr[i][j], REAL32 TRUNC ans, "INT-R32-3")
          r32arr[id(i)][j] := REAL32 TRUNC iarr[id(i)][j]
          check.REAL32(r32arr[i][j], REAL32 TRUNC ans, "INT-R32-4")
          i64arr[i][j] := INT64 iarr[i][j]
          check.INT64(i64arr[i][j], INT64 ans, "INT-I64-1")
          i64arr[id(i)][j] := INT64 iarr[id(i)][j]
          check.INT64(i64arr[i][j], INT64 ans, "INT-I64-2")
          i32arr[i][j] := INT32 iarr[i][j]
          check.INT32(i32arr[i][j], INT32 ans, "INT-I32-1")
          i32arr[id(i)][j] := INT32 iarr[id(i)][j]
          check.INT32(i32arr[i][j], INT32 ans, "INT-I32-2")
          i16arr[i][j] := INT16 iarr[i][j]
          check.INT16(i16arr[i][j], INT16 ans, "INT-I16-1")
          i16arr[id(i)][j] := INT16 iarr[id(i)][j]
          check.INT16(i16arr[i][j], INT16 ans, "INT-I16-2")
          iarr[i][j] := INT iarr[i][j]
          check.INT(iarr[i][j], INT ans, "INT-INT-1")
          iarr[id(i)][j] := INT iarr[id(i)][j]
          check.INT(iarr[i][j], INT ans, "INT-INT-2")
        --}}}
        --{{{  more constant folding (bug INSdi02215, INSdi01895)
        PROC constant.TIMES(VAL INT y)
          VAL zero.zero IS          0(INT) :
          VAL zero.one  IS          1(INT) :
          VAL zero.any  IS          2(INT) :
          VAL one.zero  IS #100(INT) :
          VAL one.one   IS #101(INT) :
          VAL one.any   IS #102(INT) :
          VAL any.zero  IS #200(INT) :
          VAL any.one   IS #201(INT) :
          VAL any.any   IS #202(INT) :
          VAL table IS [0(INT), 1(INT), 2(INT), -1(INT), -2(INT),
                        MOSTNEG INT, MOSTPOS INT, 10(INT),
                        zero.any,
                        one.zero, one.one, one.any,
                        any.zero, any.one, any.any,
                        -zero.any,
                        -one.zero, -one.one, -one.any,
                        -any.zero, -any.one, -any.any ] :
          SEQ
            SEQ z = 0 FOR SIZE table
              PROC local.check(VAL INT x, y, VAL []BYTE msg)
                check.INT(x, y TIMES table[z], msg)
              :
              INT res, x :
              SEQ
                x := id.INT(table[z])
                res := x TIMES zero.zero
                local.check(res, zero.zero, "INT-a")
                res := x TIMES zero.one
                local.check(res, zero.one, "INT-b")
                res := x TIMES zero.any
                local.check(res, zero.any, "INT-c")
                res := x TIMES one.zero
                local.check(res, one.zero, "INT-d")
                res := x TIMES one.one
                local.check(res, one.one, "INT-e")
                res := x TIMES one.any
                local.check(res, one.any, "INT-f")
                res := x TIMES any.zero
                local.check(res, any.zero, "INT-g")
                res := x TIMES any.one
                local.check(res, any.one, "INT-h")
                res := x TIMES any.any
                local.check(res, any.any, "INT-i")
                res := zero.zero TIMES x
                local.check(res, zero.zero, "INT-j")
                res := zero.one  TIMES x
                local.check(res, zero.one, "INT-k")
                res := zero.any  TIMES x
                local.check(res, zero.any, "INT-l")
                res := one.zero  TIMES x
                local.check(res, one.zero, "INT-m")
                res := one.one   TIMES x
                local.check(res, one.one, "INT-n")
                res := one.any   TIMES x
                local.check(res, one.any, "INT-o")
                res := any.zero  TIMES x
                local.check(res, any.zero, "INT-p")
                res := any.one   TIMES x
                local.check(res, any.one, "INT-q")
                res := any.any   TIMES x
                local.check(res, any.any, "INT-r")
                res := y         TIMES x
                local.check(res, y, "INT-s")
        :
        constant.TIMES(27(INT))
        --}}}
        --{{{  bug 670
        PROC bug.670()
          INT a,b :
          SEQ
            a := 2(INT)
            b := (a + 3(INT)) TIMES 3(INT)
            check.INT(b, 15(INT), "B670a")
        :
        bug.670()
        --}}}
        --{{{  bug 1000
        PROC bug.1000()
          PROC q (VAL INT a0, a1, a2, a3, a4, INT b0, b1, b2, b3, b4)
            b0, b1, b2, b3, b4 := a0, a1, a2, a3, a4
          :
          [5]INT z0, z1 :
          SEQ
            SEQ i = 0 FOR SIZE z0
              z0[i], z1[i] := INT (-i), INT 0
            q(z0[0],z0[1],z0[2],z0[3],z0[4],z1[0],z1[1],z1[2],z1[3],z1[4])
            SEQ i = 0 FOR SIZE z1
              check(INT z1[i], -i, "B1000a")
        :
        bug.1000()
        --}}}
        --{{{  bug 1150
        PROC bug.1150()
          INT x, y :
          VAL INT c IS   1(INT) :
          VAL INT d IS 100(INT) :
          SEQ
            x, y := c, d
            x := (x + x) + (y + y)
            check.INT(x, (c+c)+(d+d), "B1150a")
            x, y := c, d
            x := (x + x) - (y + y)
            check.INT(x, (c+c)-(d+d), "B1150b")
            x, y := c, d
            x := (x + x) + (x + x)
            check.INT(x, (c+c)+(c+c), "B1150c")
            x, y := c, d
            x := (x + x) - (x + x)
            check.INT(x, (c+c)-(c+c), "B1150d")
            x, y := c, d
            x := (y + y) + (x + x)
            check.INT(x, (d+d)+(c+c), "B1150e")
            x, y := c, d
            x := (y + y) - (x + x)
            check.INT(x, (d+d)-(c+c), "B1150f")
            x := #1234(INT)
            y := 1(INT)
            x := (x /\ #0FFF(INT))\/(((x>>12)+(y+1(INT)))<<12)
            check.INT(x, #3234(INT), "B1150g")
        :
        bug.1150()
        --}}}
        --{{{  bug 1274
        PROC bug.1274()
          INT x, y :
          VAL c IS 10(INT) :
          VAL d IS 20(INT) :
          SEQ
            y := c
            VAL a IS (c * c) + (c * d) :
            SEQ
              x := c
              x := (y * c) + (y * d)
              check.INT(x, a, "B1274-Ia+")
              x := c
              x := (x * c) + (y * d)
              check.INT(x, a, "B1274-Ib+")
              x := c
              x := (y * c) + (x * d)
              check.INT(x, a, "B1274-Ic+")
              x := c
              x := (x * c) + (x * d)
              check.INT(x, a, "B1274-Id+")
            VAL a IS (c * c) PLUS (c * d) :
            SEQ
              x := c
              x := (y * c) PLUS (y * d)
              check.INT(x, a, "B1274-IaP")
              x := c
              x := (x * c) PLUS (y * d)
              check.INT(x, a, "B1274-IbP")
              x := c
              x := (y * c) PLUS (x * d)
              check.INT(x, a, "B1274-IcP")
              x := c
              x := (x * c) PLUS (x * d)
              check.INT(x, a, "B1274-IdP")
            VAL a IS (c * c) * (c * d) :
            SEQ
              x := c
              x := (y * c) * (y * d)
              check.INT(x, a, "B1274-Ia**")
              x := c
              x := (x * c) * (y * d)
              check.INT(x, a, "B1274-Ib**")
              x := c
              x := (y * c) * (x * d)
              check.INT(x, a, "B1274-Ic**")
              x := c
              x := (x * c) * (x * d)
              check.INT(x, a, "B1274-Id**")
            VAL a IS (c * c) TIMES (c * d) :
            SEQ
              x := c
              x := (y * c) TIMES (y * d)
              check.INT(x, a, "B1274-IaT")
              x := c
              x := (x * c) TIMES (y * d)
              check.INT(x, a, "B1274-IbT")
              x := c
              x := (y * c) TIMES (x * d)
              check.INT(x, a, "B1274-IcT")
              x := c
              x := (x * c) TIMES (x * d)
              check.INT(x, a, "B1274-IdT")
        :
        bug.1274()
        --}}}
        --{{{  bug TS/2020
        PROC bug.TS.2020()
          INT int, mostneg, mostpos :
          SEQ
            int := (MOSTNEG INT) REM (-1(INT))
            check.INT(int, 0(INT), "B2020da")
            int := (MOSTNEG INT) REM ( 1(INT))
            check.INT(int, 0(INT), "B2020db")
            int := (MOSTPOS INT) REM (-1(INT))
            check.INT(int, 0(INT), "B2020dc")
            int := (MOSTPOS INT) REM ( 1(INT))
            check.INT(int, 0(INT), "B2020dd")
            int := (MOSTNEG INT) /   ( 1(INT))
            check.INT(int, MOSTNEG INT, "B2020de")
            int := (MOSTPOS INT) /   (-1(INT))
            check.INT(int, (MOSTNEG INT) + 1(INT), "B2020df")
            int := (MOSTPOS INT) /   ( 1(INT))
            check.INT(int, MOSTPOS INT, "B2020dg")
            mostneg, mostpos := MOSTNEG INT, MOSTPOS INT
            int := (mostneg) REM (-1(INT))
            check.INT(int, 0(INT), "B2020dh")
            int := (mostneg) REM ( 1(INT))
            check.INT(int, 0(INT), "B2020di")
            int := (mostpos) REM (-1(INT))
            check.INT(int, 0(INT), "B2020dj")
            int := (mostpos) REM ( 1(INT))
            check.INT(int, 0(INT), "B2020dk")
            int := (mostneg) /   ( 1(INT))
            check.INT(int, MOSTNEG INT, "B2020dl")
            int := (mostpos) /   (-1(INT))
            check.INT(int, (MOSTNEG INT) + 1(INT), "B2020dm")
            int := (mostpos) /   ( 1(INT))
            check.INT(int, MOSTPOS INT, "B2020dn")
        :
        bug.TS.2020()
        --}}}
        --{{{  bug INSdi02195
        PROC bug.INSdi02195()
          --{{{  functions
          BOOL   FUNCTION BOOL.fn   (VAL INT x) IS BOOL  x :
          BYTE   FUNCTION BYTE.fn   (VAL INT x) IS BYTE  x :
          INT16  FUNCTION INT16.fn  (VAL INT x) IS INT16 x :
          INT    FUNCTION INT.fn    (VAL INT x) IS x :
          INT32  FUNCTION INT32.fn  (VAL INT x) IS INT32 x :
          INT64  FUNCTION INT64.fn  (VAL INT x) IS INT64 x :
          REAL32 FUNCTION REAL32.fn (VAL INT x) IS REAL32 ROUND x :
          REAL64 FUNCTION REAL64.fn (VAL INT x) IS REAL64 ROUND x :
          --}}}
          --{{{  variables
          BOOL bool.var :
          BYTE byte.var :
          INT16 i16.var :
          INT32 i32.var :
          INT64 i64.var :
          INT   int.var :
          REAL32 r32.var :
          REAL64 r64.var :
          INT zero, int :
          --}}}
          INT local.i, local.j, local.k :
          SEQ
            zero := id(0)
            int := id(77)
            --{{{  INT var -> type -> INT         00 - 09
            local.j := id.INT(1(INT))
            local.i := INT (BOOL local.j)
            check.INT(local.i, 1(INT), "INT-00")
            local.j := id.INT(77(INT))
            local.i := INT (BYTE local.j)
            check.INT(local.i, 77(INT), "INT-01")
            local.i := INT (INT local.j)
            check.INT(local.i, 77(INT), "INT-02")
            local.i := INT (INT16 local.j)
            check.INT(local.i, 77(INT), "INT-03")
            local.i := INT (INT32 local.j)
            check.INT(local.i, 77(INT), "INT-04")
            local.i := INT (INT64 local.j)
            check.INT(local.i, 77(INT), "INT-05")
            local.i := INT ROUND (REAL32 ROUND local.j)
            check.INT(local.i, 77(INT), "INT-06")
            local.i := INT ROUND (REAL64 ROUND local.j)
            check.INT(local.i, 77(INT), "INT-07")
            --}}}
            --{{{  INT FUNCTION -> type -> INT    10 - 19
            local.j := id.INT(1(INT))
            local.i := INT (BOOL INT.fn(INT local.j))
            check.INT(local.i, 1(INT), "INT-10")
            local.j := id.INT(77(INT))
            local.i := INT (BYTE INT.fn(INT local.j))
            check.INT(local.i, 77(INT), "INT-11")
            local.i := INT (INT INT.fn(INT local.j))
            check.INT(local.i, 77(INT), "INT-12")
            local.i := INT (INT16 INT.fn(INT local.j))
            check.INT(local.i, 77(INT), "INT-13")
            local.i := INT (INT32 INT.fn(INT local.j))
            check.INT(local.i, 77(INT), "INT-14")
            local.i := INT (INT64 INT.fn(INT local.j))
            check.INT(local.i, 77(INT), "INT-15")
            local.i := INT ROUND (REAL32 ROUND (INT.fn(INT local.j)))
            check.INT(local.i, 77(INT), "INT-16")
            local.i := INT ROUND (REAL64 ROUND (INT.fn(INT local.j)))
            check.INT(local.i, 77(INT), "INT-17")
            --}}}
            --{{{  INT exp -> type -> INT         20 - 29
            local.k := id.INT(0(INT))
            local.j := id.INT(1(INT))
            local.i := INT (BOOL (local.j + local.k))
            check.INT(local.i, 1(INT), "INT-20")
            local.j := id.INT(77(INT))
            local.i := INT (BYTE (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-21")
            local.i := INT (INT (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-22")
            local.i := INT (INT16 (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-23")
            local.i := INT (INT32 (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-24")
            local.i := INT (INT64 (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-25")
            local.i := INT ROUND (REAL32 ROUND (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-26")
            local.i := INT ROUND (REAL64 ROUND (local.j + local.k))
            check.INT(local.i, 77(INT), "INT-27")
            --}}}
            --{{{  type var -> INT                  30 - 39
            bool.var := BOOL id(1)
            local.i := INT bool.var
            check.INT(local.i, 1(INT), "INT-30")
            byte.var := BYTE id(77)
            local.i := INT byte.var
            check.INT(local.i, 77(INT), "INT-31")
            int.var := id.INT(77(INT))
            local.i := INT int.var
            check.INT(local.i, 77(INT), "INT-32")
            i16.var := id.INT16(77(INT16))
            local.i := INT i16.var
            check.INT(local.i, 77(INT), "INT-33")
            i32.var := id.INT32(77(INT32))
            local.i := INT i32.var
            check.INT(local.i, 77(INT), "INT-34")
            i64.var := id.INT64(77(INT64))
            local.i := INT i64.var
            check.INT(local.i, 77(INT), "INT-35")
            r32.var := id.REAL32(77.0(REAL32))
            local.i := INT ROUND r32.var
            check.INT(local.i, 77(INT), "INT-36")
            r64.var := id.REAL64(77.0(REAL64))
            local.i := INT ROUND r64.var
            check.INT(local.i, 77(INT), "INT-37")
            --}}}
            --{{{  type FUNCTION -> INT             40 - 49
            local.i := INT BOOL.fn(zero)
            check.INT(local.i, 0(INT), "INT-40")
            local.i := INT BYTE.fn(int)
            check.INT(local.i, 77(INT), "INT-41")
            local.i := INT INT.fn(int)
            check.INT(local.i, 77(INT), "INT-42")
            local.i := INT INT16.fn(int)
            check.INT(local.i, 77(INT), "INT-43")
            local.i := INT INT32.fn(int)
            check.INT(local.i, 77(INT), "INT-44")
            local.i := INT INT64.fn(int)
            check.INT(local.i, 77(INT), "INT-45")
            local.i := INT ROUND REAL32.fn(int)
            check.INT(local.i, 77(INT), "INT-46")
            local.i := INT ROUND REAL64.fn(int)
            check.INT(local.i, 77(INT), "INT-47")
            --}}}
            --{{{  type exp -> INT                  50 - 59
            bool.var := BOOL id(1)
            local.i := INT (bool.var = bool.var)
            check.INT(local.i, 1(INT), "INT-50")
            byte.var := BYTE id(77)
            local.i := INT byte.var
            check.INT(local.i, 77(INT), "INT-51")
            int.var := id.INT(77(INT))
            local.i := INT (int.var + (INT   zero))
            check.INT(local.i, 77(INT), "INT-52")
            i16.var := id.INT16(77(INT16))
            local.i := INT (i16.var + (INT16 zero))
            check.INT(local.i, 77(INT), "INT-53")
            i32.var := id.INT32(77(INT32))
            local.i := INT (i32.var + (INT32 zero))
            check.INT(local.i, 77(INT), "INT-54")
            i64.var := id.INT64(77(INT64))
            local.i := INT (i64.var + (INT64 zero))
            check.INT(local.i, 77(INT), "INT-55")
            r32.var := id.REAL32(77.0(REAL32))
            local.i := INT ROUND (r32.var + (REAL32 ROUND zero))
            check.INT(local.i, 77(INT), "INT-56")
            r64.var := id.REAL64(77.0(REAL64))
            local.i := INT ROUND (r64.var + (REAL64 ROUND zero))
            check.INT(local.i, 77(INT), "INT-57")
            --}}}
        :
        bug.INSdi02195()
        --}}}
        --{{{  bug INSdi02423
        PROC bug.INSdi02423()
          PROC CheckOverflow ( VAL INT address, INT result)
            result := address
          :
          PROC local(VAL INT Areg, Breg, VAL INT expected0, expected1, VAL []BYTE msg)
            INT XBreg, XAreg, Xtimes :
            INT result0, result1 :
            SEQ
              CheckOverflow ( (INT Breg)TIMES(INT Areg), result0 )
              XBreg := (INT Breg)
              XAreg := (INT Areg)
              Xtimes := XAreg TIMES XBreg
              CheckOverflow (Xtimes, result1)
              check.INT(result0, expected0, msg)
              check.INT(result1, expected0, msg)
              CheckOverflow ( (INT Breg)*(INT Areg), result0 )
              Xtimes := XAreg * XBreg
              CheckOverflow (Xtimes, result1)
              check.INT(result0, expected0, msg)
              check.INT(result1, expected0, msg)
              CheckOverflow ( (INT Breg)+(INT Areg), result0 )
              Xtimes := XAreg + XBreg
              CheckOverflow (Xtimes, result1)
              check.INT(result0, expected1, msg)
              check.INT(result1, expected1, msg)
              CheckOverflow ( (INT Breg)PLUS(INT Areg), result0 )
              Xtimes := XAreg PLUS XBreg
              CheckOverflow (Xtimes, result1)
              check.INT(result0, expected1, msg)
              check.INT(result1, expected1, msg)
          :
          SEQ
            local(    1,     2,     2(INT),  3(INT), "di2423a")
            local(    2,     1,     2(INT),  3(INT), "di2423b")
            local(   -1,     2,    -2(INT),  1(INT), "di2423c")
            local(    1,    -2,    -2(INT), -1(INT), "di2423d")
            local(   -1,     1,    -1(INT),  0(INT), "di2423e")
            local(    1,    -1,    -1(INT),  0(INT), "di2423f")
            local(    1,     0,     0(INT),  1(INT), "di2423g")
            local(    0,     1,     0(INT),  1(INT), "di2423h")
            local(    0,    -1,     0(INT), -1(INT), "di2423i")
            local(   -1,     0,     0(INT), -1(INT), "di2423j")
        :
        bug.INSdi02423()
        --}}}
        --{{{  bug INSdi02439
        PROC bug.INSdi02439()
          SEQ
            PROTOCOL CONTROL  IS  INT; INT :
            CHAN OF CONTROL ControlToMonitor:
            PAR
              SEQ
                SEQ i = 0 FOR 4
                  INT   ii :
                  INT j :
                  SEQ
                    ControlToMonitor ? ii; j
                    check(i, INT j, "di2439a")
                    check(i, ii,    "di2439b")
              SEQ i = 0 FOR 4
                ControlToMonitor ! i; INT i
        :
        bug.INSdi02439()
        --}}}
    :
    do.INT ()
    --}}}
    --{{{  cg10byte.occ
    -- version control marker $Id: cg10byte.occ,v 1.1 1995/10/10 13:02:40 djb1 Exp $
    PROC do.BYTE.and.BOOL ()
      SEQ
        BYTE b :
        SEQ
          b := 85(BYTE)
          --{{{  output message
          title ("BYTE operations")
          --}}}
          --{{{  variables for conversion tests
          INT i :
          INT64 i64 :
          INT32 i32 :
          INT16 i16 :
          BYTE byte :
          BOOL bool :
          --}}}
          --{{{  check conversions
          SEQ
            i64 := INT64 b
            check.INT64 (i64, INT64 85(BYTE), "BYTE-01")
            i32 := INT32 b
            check.INT32 (i32, INT32 85(BYTE), "BYTE-02")
            i16 := INT16 b
            check.INT16 (i16, INT16 85(BYTE), "BYTE-03")
            byte := BYTE b
            check.BYTE (byte, BYTE 85(BYTE), "BYTE-04")
            i := INT b
            check.INT (i, INT 85(BYTE), "BYTE-04a")
            b := 1(BYTE)
            bool := BOOL b
            check.BOOL (bool, BOOL 1(BYTE), "BYTE-05")
          --}}}
          --{{{  check constant folding
          PROC constant.fold.bytes()
            VAL x1 IS 000(BYTE) :
            VAL x2 IS 127(BYTE) :
            VAL x3 IS 128(BYTE) :
            VAL x4 IS 255(BYTE) :
            BYTE b1, b2, b3, b4 :
            BOOL b :
            BYTE FUNCTION copy(VAL BYTE b) IS b :
            SEQ
              b1, b2, b3, b4 := copy(x1), copy(x2), copy(x3), copy(x4)
              --{{{  check a value against itself  BYTE-100 - BYTE-199
              b := b1 = b1
              check.BOOL(b,        TRUE,  "BYTE-100")
              check.BOOL(x1 = x1,  TRUE,  "BYTE-101")
              b := b1 <> b1
              check.BOOL(b,        FALSE, "BYTE-102")
              check.BOOL(x1 <> x1, FALSE, "BYTE-103")
              b := b1 < b1
              check.BOOL(b,        FALSE, "BYTE-104")
              check.BOOL(x1 < x1,  FALSE, "BYTE-105")
              b := b1 > b1
              check.BOOL(b,        FALSE, "BYTE-106")
              check.BOOL(x1 > x1,  FALSE, "BYTE-107")
              b := b1 <= b1
              check.BOOL(b,        TRUE,  "BYTE-108")
              check.BOOL(x1 <= x1, TRUE,  "BYTE-109")
              b := b1 >= b1
              check.BOOL(b,        TRUE,  "BYTE-110")
              check.BOOL(x1 >= x1, TRUE,  "BYTE-111")
              --}}}
              --{{{  check for =     BYTE-200 - BYTE-399
              b := b1 = b2
              check.BOOL(b,        FALSE, "BYTE-200")
              check.BOOL(x1 = x2,  FALSE, "BYTE-201")
              b := b1 = b3
              check.BOOL(b,        FALSE, "BYTE-202")
              check.BOOL(x1 = x3,  FALSE, "BYTE-203")
              b := b1 = b4
              check.BOOL(b,        FALSE, "BYTE-204")
              check.BOOL(x1 = x4,  FALSE, "BYTE-205")
              b := b2 = b3
              check.BOOL(b,        FALSE, "BYTE-206")
              check.BOOL(x2 = x3,  FALSE, "BYTE-207")
              b := b2 = b4
              check.BOOL(b,        FALSE, "BYTE-208")
              check.BOOL(x2 = x4,  FALSE, "BYTE-209")
              b := b3 = b4
              check.BOOL(b,        FALSE, "BYTE-210")
              check.BOOL(x3 = x4,  FALSE, "BYTE-211")
              --}}}
              --{{{  check for <>    BYTE-300 - BYTE-399
              b := b1 <> b2
              check.BOOL(b,        TRUE,  "BYTE-300")
              check.BOOL(x1 <> x2, TRUE,  "BYTE-301")
              b := b1 <> b3
              check.BOOL(b,        TRUE,  "BYTE-302")
              check.BOOL(x1 <> x3, TRUE,  "BYTE-303")
              b := b1 <> b4
              check.BOOL(b,        TRUE,  "BYTE-304")
              check.BOOL(x1 <> x4, TRUE,  "BYTE-305")
              b := b2 <> b3
              check.BOOL(b,        TRUE,  "BYTE-306")
              check.BOOL(x2 <> x3, TRUE,  "BYTE-307")
              b := b2 <> b4
              check.BOOL(b,        TRUE,  "BYTE-308")
              check.BOOL(x2 <> x4, TRUE,  "BYTE-309")
              b := b3 <> b4
              check.BOOL(b,        TRUE,  "BYTE-310")
              check.BOOL(x3 <> x4, TRUE,  "BYTE-311")
              --}}}
              --{{{  check for <     BYTE-400 - BYTE-499
              b := b1 < b2
              check.BOOL(b,        TRUE,  "BYTE-400")
              check.BOOL(x1 < x2,  TRUE,  "BYTE-401")
              b := b1 < b3
              check.BOOL(b,        TRUE,  "BYTE-402")
              check.BOOL(x1 < x3,  TRUE,  "BYTE-403")
              b := b1 < b4
              check.BOOL(b,        TRUE,  "BYTE-404")
              check.BOOL(x1 < x4,  TRUE,  "BYTE-405")
              b := b2 < b3
              check.BOOL(b,        TRUE,  "BYTE-406")
              check.BOOL(x2 < x3,  TRUE,  "BYTE-407")
              b := b2 < b4
              check.BOOL(b,        TRUE,  "BYTE-408")
              check.BOOL(x2 < x4,  TRUE,  "BYTE-409")
              b := b3 < b4
              check.BOOL(b,        TRUE,  "BYTE-410")
              check.BOOL(x3 < x4,  TRUE,  "BYTE-411")
              --}}}
              --{{{  check for >     BYTE-500 - BYTE-599
              b := b1 > b2
              check.BOOL(b,        FALSE, "BYTE-500")
              check.BOOL(x1 > x2,  FALSE, "BYTE-501")
              b := b1 > b3
              check.BOOL(b,        FALSE, "BYTE-502")
              check.BOOL(x1 > x3,  FALSE, "BYTE-503")
              b := b1 > b4
              check.BOOL(b,        FALSE, "BYTE-504")
              check.BOOL(x1 > x4,  FALSE, "BYTE-505")
              b := b2 > b3
              check.BOOL(b,        FALSE, "BYTE-506")
              check.BOOL(x2 > x3,  FALSE, "BYTE-507")
              b := b2 > b4
              check.BOOL(b,        FALSE, "BYTE-508")
              check.BOOL(x2 > x4,  FALSE, "BYTE-509")
              b := b3 > b4
              check.BOOL(b,        FALSE, "BYTE-510")
              check.BOOL(x3 > x4,  FALSE, "BYTE-511")
              --}}}
              --{{{  check for <=    BYTE-600 - BYTE-699
              b := b1 <= b2
              check.BOOL(b,        TRUE,  "BYTE-600")
              check.BOOL(x1 <= x2, TRUE,  "BYTE-601")
              b := b1 <= b3
              check.BOOL(b,        TRUE,  "BYTE-602")
              check.BOOL(x1 <= x3, TRUE,  "BYTE-603")
              b := b1 <= b4
              check.BOOL(b,        TRUE,  "BYTE-604")
              check.BOOL(x1 <= x4, TRUE,  "BYTE-605")
              b := b2 <= b3
              check.BOOL(b,        TRUE,  "BYTE-606")
              check.BOOL(x2 <= x3, TRUE,  "BYTE-607")
              b := b2 <= b4
              check.BOOL(b,        TRUE,  "BYTE-608")
              check.BOOL(x2 <= x4, TRUE,  "BYTE-609")
              b := b3 <= b4
              check.BOOL(b,        TRUE,  "BYTE-610")
              check.BOOL(x3 <= x4, TRUE,  "BYTE-611")
              --}}}
              --{{{  check for >=    BYTE-700 - BYTE-799
              b := b1 >= b2
              check.BOOL(b,        FALSE, "BYTE-700")
              check.BOOL(x1 >= x2, FALSE, "BYTE-701")
              b := b1 >= b3
              check.BOOL(b,        FALSE, "BYTE-702")
              check.BOOL(x1 >= x3, FALSE, "BYTE-703")
              b := b1 >= b4
              check.BOOL(b,        FALSE, "BYTE-704")
              check.BOOL(x1 >= x4, FALSE, "BYTE-705")
              b := b2 >= b3
              check.BOOL(b,        FALSE, "BYTE-706")
              check.BOOL(x2 >= x3, FALSE, "BYTE-707")
              b := b2 >= b4
              check.BOOL(b,        FALSE, "BYTE-708")
              check.BOOL(x2 >= x4, FALSE, "BYTE-709")
              b := b3 >= b4
              check.BOOL(b,        FALSE, "BYTE-710")
              check.BOOL(x3 >= x4, FALSE, "BYTE-711")
              --}}}
          :
          constant.fold.bytes()
          --}}}
        BOOL b :
        SEQ
          b := BOOL 1
          --{{{  output message
          title ("BOOL operations")
          --}}}
          --{{{  variables for conversion tests
          INT i :
          INT64 i64 :
          INT32 i32 :
          INT16 i16 :
          BYTE byte :
          BOOL bool :
          --}}}
          --{{{  conversion tests                    (BOOL-00 to 09)
          SEQ
            i64 := INT64 b
            check.INT64 (i64, INT64 (BOOL 1), "BOOL-01")
            i32 := INT32 b
            check.INT32 (i32, INT32 (BOOL 1), "BOOL-02")
            i16 := INT16 b
            check.INT16 (i16, INT16 (BOOL 1), "BOOL-03")
            byte := BYTE b
            check.BYTE (byte, BYTE (BOOL 1), "BOOL-04")
            i := INT b
            check.INT (i, INT (BOOL 1), "BOOL-04a")
            b := BOOL 1
            bool := BOOL b
            check.BOOL (bool, BOOL (BOOL 1), "BOOL-05")
          --}}}
    :
    do.BYTE.and.BOOL ()
    --}}}
    --{{{  cg10long.occ
    -- version control marker $Id: cg10long.occ,v 1.1 1995/10/10 13:03:18 djb1 Exp $
    PROC do.other ()
      SEQ
        --{{{  output message
        title ("Other tests")
        --}}}
        --{{{  protocol testing                (P000 - P999)
        --{{{  INT64                           (P000 - P009)
        CHAN OF INT64 c :
        INT64 x, y :
        SEQ
          PAR
            c ! 722 (INT64)
            c ? x
          PAR
            c ! 0 (INT64)
            c ? y
          check.INT64 (x, 722(INT64), "P001")
          check.INT64 (y,   0(INT64), "P002")
        --}}}
        --}}}
        --{{{  long constants                  (L000 - L999)
        --{{{  plain INT32 long constants      (L001 - L099)
        VAL l1 IS #10000000(INT32) :
        VAL l2 IS #20000000(INT32) :
        VAL l3 IS #12345678(INT32) :
        VAL l4 IS #ABCDEF(INT32)   :
        INT32 x1, x2, x3, x4 :
        SEQ
          x1 := l1
          x2 := l2
          x3 := l3
          x4 := l4
          check.INT32  (l1, #10000000(INT32), "L001")
          check.INT32  (l2, #20000000(INT32), "L002")
          check.INT32  (l3, #12345678(INT32), "L003")
          check.INT32  (l4,   #ABCDEF(INT32), "L004")
          check.INT32  (x1, #10000000(INT32), "L011")
          check.INT32  (x2, #20000000(INT32), "L012")
          check.INT32  (x3, #12345678(INT32), "L013")
          check.INT32  (x4,   #ABCDEF(INT32), "L014")
          check.INT32  (l1 + l1, l2, "L021")
          check.INT32  (l1 + l1, #20000000(INT32), "L022")
          check.INT32  (x1 - x1, 0(INT32), "L023")
          check.INT32  (x2 - x2, 0(INT32), "L024")
          check.INT32  (x3 - x3, 0(INT32), "L025")
          check.INT32  (x4 - x4, 0(INT32), "L026")
          check.INT32  (x2 - x1, l1, "L027")
        --}}}
        --{{{  INT32 inside procedures         (L100 - L299)
        VAL ext IS #10000000(INT32) :
        INT32 x, y, z :
        SEQ
          --{{{  none  (L100 - 109)
          PROC none (INT32 x)
            x := ext
          :
          SEQ
            x := 0(INT32)
            check.INT32  (x, 0(INT32), "L100")
            none (x)
            check.INT32  (x, #10000000(INT32), "L101")
          --}}}
          --{{{  one   (L110 - 119)
          PROC one (INT32 x)
            VAL n IS #20000000(INT32) :
            x := n
          :
          SEQ
            x := 2(INT32)
            check.INT32  (x, 2(INT32), "L110")
            one (x)
            check.INT32  (x, #20000000(INT32), "L111")
            one (y)
            check.INT32  (y, #20000000(INT32), "L112")
          --}}}
          --{{{  one.a (L120 - 129)
          PROC one.a (INT32 x)
            x := #30000000(INT32)
          :
          SEQ
            z := 13(INT32)
            check.INT32  (z, 13(INT32), "L120")
            one.a (z)
            check.INT32  (z, #30000000(INT32), "L121")
          --}}}
          --{{{  one.b (L130 - 139)
          PROC one.b (INT32 x)
            VAL n IS #20000000(INT32) :
            x := ext
          :
          SEQ
            y := 42(INT32)
            check.INT32  (y, 42(INT32), "L130")
            one.b (y)
            check.INT32  (y, #10000000(INT32), "L131")
          --}}}
          --{{{  two   (L140 - 149)
          PROC two (INT32 x, y)
            VAL n IS #12345678(INT32) :
            VAL m IS #87654321(INT32) :
            SEQ
              x := n
              y := m
              check.INT32  (n, #12345678(INT32), "L142")
              check.INT32  (m, #87654321(INT32), "L143")
              check.INT32  (ext, #10000000(INT32), "L144")
          :
          SEQ
            x := 42(INT32)
            y := 13(INT32)
            check.INT32  (x, 42(INT32), "L140")
            check.INT32  (y, 13(INT32), "L141")
            two (x, y)
            check.INT32  (x, #12345678(INT32), "L145")
            check.INT32  (y, #87654321(INT32), "L146")
          --}}}
          --{{{  two.a (L150 - 159)
          PROC two.a (INT32 x, y)
            SEQ
              x := #12345678(INT32)
              y := #87654321(INT32)
          :
          SEQ
            x := 67(INT32)
            z := 65(INT32)
            check.INT32  (x, 67(INT32), "L150")
            check.INT32  (z, 65(INT32), "L151")
            two.a (x, z)
            check.INT32  (x, #12345678(INT32), "L152")
            check.INT32  (z, #87654321(INT32), "L153")
          --}}}
          --{{{  two.b (L160 - 169)
          PROC two.b (INT32 x, y)
            SEQ
              x := ext
              y := ext
          :
          SEQ
            x := 0(INT32)
            y := x
            check.INT32  (x, 0(INT32), "L160")
            check.INT32  (y, 0(INT32), "L161")
            two.b (x, y)
            check.INT32  (x, #10000000(INT32), "L162")
            check.INT32  (y, #10000000(INT32), "L163")
            check.INT32  (x, ext, "L164")
            check.INT32  (y, ext, "L165")
          --}}}
          --{{{  lots  (L200 - 299)
          PROC lots (INT32 x, y, z)
            --{{{  declarations
            VAL n1 IS #12345678(INT32) :
            VAL n2 IS #98765432(INT32) :
            VAL n3 IS #555555(INT32) :
            VAL n4 IS #0(INT32) :
            VAL n5 IS #AAAAAAAA(INT32) :
            VAL n6 IS #FFFFFFFF(INT32) :
            VAL nn IS [#12345678(INT32),#87654321(INT32),
                       #FFFFFFFF(INT32),#00000000(INT32)] :
            VAL n7 IS #56789ABC(INT32) :
            INT32 a,b,c,d,e :
            --}}}
            SEQ
              a := n1
              b := n2
              c := n3
              d := n4
              x := n5
              e := n6
              y := nn [1]
              z := n7
              --{{{  checking
              check.INT32  (a,  #12345678(INT32), "L200")
              check.INT32  (n1, #12345678(INT32), "L201")
              check.INT32  (b,  #98765432(INT32), "L202")
              check.INT32  (n2, #98765432(INT32), "L203")
              check.INT32  (c,    #555555(INT32), "L204")
              check.INT32  (n3,   #555555(INT32), "L205")
              check.INT32  (d,          0(INT32), "L206")
              check.INT32  (n4,         0(INT32), "L207")
              check.INT32  (x,  #AAAAAAAA(INT32), "L208")
              check.INT32  (n5, #AAAAAAAA(INT32), "L209")
              check.INT32  (e,  #FFFFFFFF(INT32), "L210")
              check.INT32  (n6, #FFFFFFFF(INT32), "L211")
              check.INT32  (y,  #87654321(INT32), "L212")
              check.INT32  (z,  #56789ABC(INT32), "L213")
              check.INT32  (n7, #56789ABC(INT32), "L214")
              check.INT32  (nn [1], #87654321(INT32), "L215")
              --}}}
          :
          SEQ
            lots (z, y, x)
            check.INT32  (x, #56789ABC(INT32), "L230")
            check.INT32  (y, #87654321(INT32), "L231")
            check.INT32  (z, #AAAAAAAA(INT32), "L232")
          --}}}
        --}}}
        --{{{  plain INT64 long constants      (L601 - L699)
        VAL l1 IS #1000000087654321(INT64) :
        VAL l2 IS #2000000087654321(INT64) :
        VAL l3 IS #1234567887654321(INT64) :
        VAL l4 IS #ABCDEF87654321(INT64)   :
        INT64 x1, x2, x3, x4 :
        SEQ
          x1 := l1
          x2 := l2
          x3 := l3
          x4 := l4
          check.INT64  (l1,      #1000000087654321(INT64), "L601")
          check.INT64  (l2,      #2000000087654321(INT64), "L602")
          check.INT64  (l3,      #1234567887654321(INT64), "L603")
          check.INT64  (l4,        #ABCDEF87654321(INT64), "L604")
          check.INT64  (x1,      #1000000087654321(INT64), "L611")
          check.INT64  (x2,      #2000000087654321(INT64), "L612")
          check.INT64  (x3,      #1234567887654321(INT64), "L613")
          check.INT64  (x4,        #ABCDEF87654321(INT64), "L614")
          check.INT64  (l1 + l1, #200000010ECA8642(INT64), "L622")
          check.INT64  (x1 - x1, 0(INT64), "L623")
          check.INT64  (x2 - x2, 0(INT64), "L624")
          check.INT64  (x3 - x3, 0(INT64), "L625")
          check.INT64  (x4 - x4, 0(INT64), "L626")
          check.INT64  (x2 - x1, #1000000000000000(INT64), "L627")
        --}}}
        --{{{  INT64 inside procedures         (L700 - L899)
        VAL ext IS #1000000087654321(INT64) :
        INT64 x, y, z :
        SEQ
          --{{{  none  (L700 - 109)
          PROC none (INT64 x)
            x := ext
          :
          SEQ
            x := 087654321(INT64)
            check.INT64  (x, 087654321(INT64), "L700")
            none (x)
            check.INT64  (x, #1000000087654321(INT64), "L701")
          --}}}
          --{{{  one   (L710 - 119)
          PROC one (INT64 x)
            VAL n IS #2000000087654321(INT64) :
            x := n
          :
          SEQ
            x := 287654321(INT64)
            check.INT64  (x, 287654321(INT64), "L710")
            one (x)
            check.INT64  (x, #2000000087654321(INT64), "L711")
            one (y)
            check.INT64  (y, #2000000087654321(INT64), "L712")
          --}}}
          --{{{  one.a (L720 - 129)
          PROC one.a (INT64 x)
            x := #3000000087654321(INT64)
          :
          SEQ
            z := 1387654321(INT64)
            check.INT64  (z, 1387654321(INT64), "L720")
            one.a (z)
            check.INT64  (z, #3000000087654321(INT64), "L721")
          --}}}
          --{{{  one.b (L730 - 139)
          PROC one.b (INT64 x)
            VAL n IS #2000000087654321(INT64) :
            x := ext
          :
          SEQ
            y := 4287654321(INT64)
            check.INT64  (y, 4287654321(INT64), "L730")
            one.b (y)
            check.INT64  (y, #1000000087654321(INT64), "L731")
          --}}}
          --{{{  two   (L740 - 149)
          PROC two (INT64 x, y)
            VAL n IS #1234567887654321(INT64) :
            VAL m IS #8765432187654321(INT64) :
            SEQ
              x := n
              y := m
              check.INT64  (n, #1234567887654321(INT64), "L742")
              check.INT64  (m, #8765432187654321(INT64), "L743")
              check.INT64  (ext, #1000000087654321(INT64), "L744")
          :
          SEQ
            x := 4287654321(INT64)
            y := 1387654321(INT64)
            check.INT64  (x, 4287654321(INT64), "L740")
            check.INT64  (y, 1387654321(INT64), "L741")
            two (x, y)
            check.INT64  (x, #1234567887654321(INT64), "L745")
            check.INT64  (y, #8765432187654321(INT64), "L746")
          --}}}
          --{{{  two.a (L750 - 159)
          PROC two.a (INT64 x, y)
            SEQ
              x := #1234567887654321(INT64)
              y := #8765432187654321(INT64)
          :
          SEQ
            x := 6787654321(INT64)
            z := 6587654321(INT64)
            check.INT64  (x, 6787654321(INT64), "L750")
            check.INT64  (z, 6587654321(INT64), "L751")
            two.a (x, z)
            check.INT64  (x, #1234567887654321(INT64), "L752")
            check.INT64  (z, #8765432187654321(INT64), "L753")
          --}}}
          --{{{  two.b (L760 - 169)
          PROC two.b (INT64 x, y)
            SEQ
              x := ext
              y := ext
          :
          SEQ
            x := 087654321(INT64)
            y := x
            check.INT64  (x, 087654321(INT64), "L760")
            check.INT64  (y, 087654321(INT64), "L761")
            two.b (x, y)
            check.INT64  (x, #1000000087654321(INT64), "L762")
            check.INT64  (y, #1000000087654321(INT64), "L763")
            check.INT64  (x, ext, "L764")
            check.INT64  (y, ext, "L765")
          --}}}
          --{{{  lots  (L800 - 299)
          PROC lots (INT64 x, y, z)
            --{{{  declarations
            VAL n1 IS #1234567887654321(INT64) :
            VAL n2 IS #9876543287654321(INT64) :
            VAL n3 IS   #55555587654321(INT64) :
            VAL n4 IS        #087654321(INT64) :
            VAL n5 IS #AAAAAAAA87654321(INT64) :
            VAL n6 IS #FFFFFFFF87654321(INT64) :
            VAL nn IS [#1234567887654321(INT64),#8765432187654321(INT64),
                       #FFFFFFFF87654321(INT64),#0000000087654321(INT64)] :
            VAL n7 IS #56789ABC87654321(INT64) :
            INT64 a,b,c,d,e :
            --}}}
            SEQ
              a := n1
              b := n2
              c := n3
              d := n4
              x := n5
              e := n6
              y := nn [1]
              z := n7
              --{{{  checking
              check.INT64  (a,  #1234567887654321(INT64), "L800")
              check.INT64  (n1, #1234567887654321(INT64), "L801")
              check.INT64  (b,  #9876543287654321(INT64), "L802")
              check.INT64  (n2, #9876543287654321(INT64), "L803")
              check.INT64  (c,    #55555587654321(INT64), "L804")
              check.INT64  (n3,   #55555587654321(INT64), "L805")
              check.INT64  (d,         #087654321(INT64), "L806")
              check.INT64  (n4,        #087654321(INT64), "L807")
              check.INT64  (x,  #AAAAAAAA87654321(INT64), "L808")
              check.INT64  (n5, #AAAAAAAA87654321(INT64), "L809")
              check.INT64  (e,  #FFFFFFFF87654321(INT64), "L810")
              check.INT64  (n6, #FFFFFFFF87654321(INT64), "L811")
              check.INT64  (y,  #8765432187654321(INT64), "L812")
              check.INT64  (z,  #56789ABC87654321(INT64), "L813")
              check.INT64  (n7, #56789ABC87654321(INT64), "L814")
              check.INT64  (nn [1], #8765432187654321(INT64), "L815")
              --}}}
          :
          SEQ
            lots (z, y, x)
            check.INT64  (x, #56789ABC87654321(INT64), "L830")
            check.INT64  (y, #8765432187654321(INT64), "L831")
            check.INT64  (z, #AAAAAAAA87654321(INT64), "L832")
          --}}}
        --}}}
        --}}}
    :
    do.other ()
    --}}}
    finish ()
:
